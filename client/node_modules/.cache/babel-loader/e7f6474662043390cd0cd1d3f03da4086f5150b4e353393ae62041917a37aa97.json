{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableGraphQLExtensions = exports.GraphQLExtensionStack = exports.GraphQLExtension = void 0;\nconst graphql_1 = require(\"graphql\");\nclass GraphQLExtension {}\nexports.GraphQLExtension = GraphQLExtension;\nclass GraphQLExtensionStack {\n  constructor(extensions) {\n    this.extensions = extensions;\n  }\n  requestDidStart(o) {\n    return this.handleDidStart(ext => ext.requestDidStart && ext.requestDidStart(o));\n  }\n  parsingDidStart(o) {\n    return this.handleDidStart(ext => ext.parsingDidStart && ext.parsingDidStart(o));\n  }\n  validationDidStart() {\n    return this.handleDidStart(ext => ext.validationDidStart && ext.validationDidStart());\n  }\n  executionDidStart(o) {\n    if (o.executionArgs.fieldResolver) {\n      this.fieldResolver = o.executionArgs.fieldResolver;\n    }\n    return this.handleDidStart(ext => ext.executionDidStart && ext.executionDidStart(o));\n  }\n  didEncounterErrors(errors) {\n    this.extensions.forEach(extension => {\n      if (extension.didEncounterErrors) {\n        extension.didEncounterErrors(errors);\n      }\n    });\n  }\n  willSendResponse(o) {\n    let reference = o;\n    [...this.extensions].reverse().forEach(extension => {\n      if (extension.willSendResponse) {\n        const result = extension.willSendResponse(reference);\n        if (result) {\n          reference = result;\n        }\n      }\n    });\n    return reference;\n  }\n  willResolveField(source, args, context, info) {\n    const handlers = this.extensions.map(extension => extension.willResolveField && extension.willResolveField(source, args, context, info)).filter(x => x).reverse();\n    return (error, result) => {\n      for (const handler of handlers) {\n        handler(error, result);\n      }\n    };\n  }\n  format() {\n    return this.extensions.map(extension => extension.format && extension.format()).filter(x => x).reduce((extensions, _ref) => {\n      let [key, value] = _ref;\n      return Object.assign(extensions, {\n        [key]: value\n      });\n    }, {});\n  }\n  handleDidStart(startInvoker) {\n    const endHandlers = [];\n    this.extensions.forEach(extension => {\n      try {\n        const endHandler = startInvoker(extension);\n        if (endHandler) {\n          endHandlers.push(endHandler);\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    });\n    return function () {\n      endHandlers.reverse();\n      for (const endHandler of endHandlers) {\n        try {\n          endHandler(...arguments);\n        } catch (error) {\n          console.error(error);\n        }\n      }\n    };\n  }\n}\nexports.GraphQLExtensionStack = GraphQLExtensionStack;\nfunction enableGraphQLExtensions(schema) {\n  if (schema._extensionsEnabled) {\n    return schema;\n  }\n  schema._extensionsEnabled = true;\n  forEachField(schema, wrapField);\n  return schema;\n}\nexports.enableGraphQLExtensions = enableGraphQLExtensions;\nfunction wrapField(field) {\n  const fieldResolver = field.resolve;\n  field.resolve = (source, args, context, info) => {\n    const parentPath = info.path.prev;\n    const extensionStack = context && context._extensionStack;\n    const handler = extensionStack && extensionStack.willResolveField(source, args, context, info) || ((_err, _result) => {});\n    const resolveObject = info.parentType.resolveObject;\n    let whenObjectResolved;\n    if (parentPath && resolveObject) {\n      if (!parentPath.__fields) {\n        parentPath.__fields = {};\n      }\n      parentPath.__fields[info.fieldName] = info.fieldNodes;\n      whenObjectResolved = parentPath.__whenObjectResolved;\n      if (!whenObjectResolved) {\n        whenObjectResolved = Promise.resolve().then(() => {\n          return resolveObject(source, parentPath.__fields, context, info);\n        });\n        parentPath.__whenObjectResolved = whenObjectResolved;\n      }\n    }\n    try {\n      const actualFieldResolver = fieldResolver || extensionStack && extensionStack.fieldResolver || graphql_1.defaultFieldResolver;\n      let result;\n      if (whenObjectResolved) {\n        result = whenObjectResolved.then(resolvedObject => {\n          return actualFieldResolver(resolvedObject, args, context, info);\n        });\n      } else {\n        result = actualFieldResolver(source, args, context, info);\n      }\n      whenResultIsFinished(result, handler);\n      return result;\n    } catch (error) {\n      handler(error);\n      throw error;\n    }\n  };\n}\nfunction isPromise(x) {\n  return x && typeof x.then === 'function';\n}\nfunction whenResultIsFinished(result, callback) {\n  if (isPromise(result)) {\n    result.then(r => callback(null, r), err => callback(err));\n  } else if (Array.isArray(result)) {\n    if (result.some(isPromise)) {\n      Promise.all(result).then(r => callback(null, r), err => callback(err));\n    } else {\n      callback(null, result);\n    }\n  } else {\n    callback(null, result);\n  }\n}\nfunction forEachField(schema, fn) {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(typeName => {\n    const type = typeMap[typeName];\n    if (!graphql_1.getNamedType(type).name.startsWith('__') && type instanceof graphql_1.GraphQLObjectType) {\n      const fields = type.getFields();\n      Object.keys(fields).forEach(fieldName => {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}","map":{"version":3,"names":["graphql_1","require","GraphQLExtension","exports","GraphQLExtensionStack","constructor","extensions","requestDidStart","o","handleDidStart","ext","parsingDidStart","validationDidStart","executionDidStart","executionArgs","fieldResolver","didEncounterErrors","errors","forEach","extension","willSendResponse","reference","reverse","result","willResolveField","source","args","context","info","handlers","map","filter","x","error","handler","format","reduce","_ref","key","value","Object","assign","startInvoker","endHandlers","endHandler","push","console","arguments","enableGraphQLExtensions","schema","_extensionsEnabled","forEachField","wrapField","field","resolve","parentPath","path","prev","extensionStack","_extensionStack","_err","_result","resolveObject","parentType","whenObjectResolved","__fields","fieldName","fieldNodes","__whenObjectResolved","Promise","then","actualFieldResolver","defaultFieldResolver","resolvedObject","whenResultIsFinished","isPromise","callback","r","err","Array","isArray","some","all","fn","typeMap","getTypeMap","keys","typeName","type","getNamedType","name","startsWith","GraphQLObjectType","fields","getFields"],"sources":["/Users/venusrodin/node_modules/graphql-extensions/src/index.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  GraphQLObjectType,\n  getNamedType,\n  GraphQLField,\n  defaultFieldResolver,\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  ExecutionArgs,\n  DocumentNode,\n  ResponsePath,\n  FieldNode,\n  GraphQLError,\n} from 'graphql';\n\nimport { Request } from 'apollo-server-env';\n\nimport { GraphQLResponse, GraphQLRequestContext } from 'apollo-server-types';\nexport { GraphQLResponse };\n\nimport { GraphQLObjectResolver } from '@apollographql/apollo-tools';\n\nexport type EndHandler = (...errors: Array<Error>) => void;\n// A StartHandlerInvoker is a function that, given a specific GraphQLExtension,\n// finds a specific StartHandler on that extension and calls it with appropriate\n// arguments.\ntype StartHandlerInvoker<TContext = any> = (\n  ext: GraphQLExtension<TContext>,\n) => EndHandler | void;\n\nexport class GraphQLExtension<TContext = any> {\n  public requestDidStart?(o: {\n    request: Pick<Request, 'url' | 'method' | 'headers'>;\n    queryString?: string;\n    parsedQuery?: DocumentNode;\n    operationName?: string;\n    variables?: { [key: string]: any };\n    persistedQueryHit?: boolean;\n    persistedQueryRegister?: boolean;\n    context: TContext;\n    requestContext: GraphQLRequestContext<TContext>;\n  }): EndHandler | void;\n  public parsingDidStart?(o: { queryString: string }): EndHandler | void;\n  public validationDidStart?(): EndHandler | void;\n  public executionDidStart?(o: {\n    executionArgs: ExecutionArgs;\n  }): EndHandler | void;\n\n  public didEncounterErrors?(errors: ReadonlyArray<GraphQLError>): void;\n\n  public willSendResponse?(o: {\n    graphqlResponse: GraphQLResponse;\n    context: TContext;\n  }): void | { graphqlResponse: GraphQLResponse; context: TContext };\n\n  public willResolveField?(\n    source: any,\n    args: { [argName: string]: any },\n    context: TContext,\n    info: GraphQLResolveInfo,\n  ): ((error: Error | null, result?: any) => void) | void;\n\n  public format?(): [string, any] | undefined;\n}\n\nexport class GraphQLExtensionStack<TContext = any> {\n  public fieldResolver?: GraphQLFieldResolver<any, any>;\n\n  private extensions: GraphQLExtension<TContext>[];\n\n  constructor(extensions: GraphQLExtension<TContext>[]) {\n    this.extensions = extensions;\n  }\n\n  public requestDidStart(o: {\n    request: Pick<Request, 'url' | 'method' | 'headers'>;\n    queryString?: string;\n    parsedQuery?: DocumentNode;\n    operationName?: string;\n    variables?: { [key: string]: any };\n    persistedQueryHit?: boolean;\n    persistedQueryRegister?: boolean;\n    context: TContext;\n    extensions?: Record<string, any>;\n    requestContext: GraphQLRequestContext<TContext>;\n  }): EndHandler {\n    return this.handleDidStart(\n      ext => ext.requestDidStart && ext.requestDidStart(o),\n    );\n  }\n  public parsingDidStart(o: { queryString: string }): EndHandler {\n    return this.handleDidStart(\n      ext => ext.parsingDidStart && ext.parsingDidStart(o),\n    );\n  }\n  public validationDidStart(): EndHandler {\n    return this.handleDidStart(\n      ext => ext.validationDidStart && ext.validationDidStart(),\n    );\n  }\n  public executionDidStart(o: { executionArgs: ExecutionArgs }): EndHandler {\n    if (o.executionArgs.fieldResolver) {\n      this.fieldResolver = o.executionArgs.fieldResolver;\n    }\n    return this.handleDidStart(\n      ext => ext.executionDidStart && ext.executionDidStart(o),\n    );\n  }\n\n  public didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {\n    this.extensions.forEach(extension => {\n      if (extension.didEncounterErrors) {\n        extension.didEncounterErrors(errors);\n      }\n    });\n  }\n\n  public willSendResponse(o: {\n    graphqlResponse: GraphQLResponse;\n    context: TContext;\n  }): { graphqlResponse: GraphQLResponse; context: TContext } {\n    let reference = o;\n    // Reverse the array, since this is functions as an end handler\n    [...this.extensions].reverse().forEach(extension => {\n      if (extension.willSendResponse) {\n        const result = extension.willSendResponse(reference);\n        if (result) {\n          reference = result;\n        }\n      }\n    });\n    return reference;\n  }\n\n  public willResolveField(\n    source: any,\n    args: { [argName: string]: any },\n    context: TContext,\n    info: GraphQLResolveInfo,\n  ) {\n    const handlers = this.extensions\n      .map(\n        extension =>\n          extension.willResolveField &&\n          extension.willResolveField(source, args, context, info),\n      )\n      .filter(x => x)\n      // Reverse list so that handlers \"nest\", like in handleDidStart.\n      .reverse() as ((error: Error | null, result?: any) => void)[];\n\n    return (error: Error | null, result?: any) => {\n      for (const handler of handlers) {\n        handler(error, result);\n      }\n    };\n  }\n\n  public format() {\n    return (this.extensions\n      .map(extension => extension.format && extension.format())\n      .filter(x => x) as [string, any][]).reduce(\n      (extensions, [key, value]) => Object.assign(extensions, { [key]: value }),\n      {},\n    );\n  }\n\n  private handleDidStart(startInvoker: StartHandlerInvoker): EndHandler {\n    const endHandlers: EndHandler[] = [];\n    this.extensions.forEach(extension => {\n      // Invoke the start handler, which may return an end handler.\n      try {\n        const endHandler = startInvoker(extension);\n        if (endHandler) {\n          endHandlers.push(endHandler);\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    });\n    return (...errors: Array<Error>) => {\n      // We run end handlers in reverse order of start handlers. That way, the\n      // first handler in the stack \"surrounds\" the entire event's process\n      // (helpful for tracing/reporting!)\n      endHandlers.reverse();\n      for (const endHandler of endHandlers) {\n        try {\n          endHandler(...errors);\n        } catch (error) {\n          console.error(error);\n        }\n      }\n    };\n  }\n}\n\nexport function enableGraphQLExtensions(\n  schema: GraphQLSchema & { _extensionsEnabled?: boolean },\n) {\n  if (schema._extensionsEnabled) {\n    return schema;\n  }\n  schema._extensionsEnabled = true;\n\n  forEachField(schema, wrapField);\n\n  return schema;\n}\n\nfunction wrapField(field: GraphQLField<any, any>): void {\n  const fieldResolver = field.resolve;\n\n  field.resolve = (source, args, context, info) => {\n    // This is a bit of a hack, but since `ResponsePath` is a linked list,\n    // a new object gets created every time a path segment is added.\n    // So we can use that to share our `whenObjectResolved` promise across\n    // all field resolvers for the same object.\n    const parentPath = info.path.prev as ResponsePath & {\n      __fields?: Record<string, ReadonlyArray<FieldNode>>;\n      __whenObjectResolved?: Promise<any>;\n    };\n\n    const extensionStack = context && context._extensionStack;\n    const handler =\n      (extensionStack &&\n        extensionStack.willResolveField(source, args, context, info)) ||\n      ((_err: Error | null, _result?: any) => {\n        /* do nothing */\n      });\n\n    const resolveObject: GraphQLObjectResolver<\n      any,\n      any\n    > = (info.parentType as any).resolveObject;\n\n    let whenObjectResolved: Promise<any> | undefined;\n\n    if (parentPath && resolveObject) {\n      if (!parentPath.__fields) {\n        parentPath.__fields = {};\n      }\n\n      parentPath.__fields[info.fieldName] = info.fieldNodes;\n\n      whenObjectResolved = parentPath.__whenObjectResolved;\n      if (!whenObjectResolved) {\n        // Use `Promise.resolve().then()` to delay executing\n        // `resolveObject()` so we can collect all the fields first.\n        whenObjectResolved = Promise.resolve().then(() => {\n          return resolveObject(source, parentPath.__fields!, context, info);\n        });\n        parentPath.__whenObjectResolved = whenObjectResolved;\n      }\n    }\n\n    try {\n      // If no resolver has been defined for a field, use either the configured\n      // field resolver or the default field resolver\n      // (which matches the behavior of graphql-js when there is no explicit\n      // resolve function defined).\n      // XXX: Can't this be pulled up to the top of `wrapField` and only\n      // assigned once? It seems `extensionStack.fieldResolver` isn't set\n      // anywhere?\n      const actualFieldResolver =\n        fieldResolver ||\n        (extensionStack && extensionStack.fieldResolver) ||\n        defaultFieldResolver;\n\n      let result: any;\n      if (whenObjectResolved) {\n        result = whenObjectResolved.then((resolvedObject: any) => {\n          return actualFieldResolver(resolvedObject, args, context, info);\n        });\n      } else {\n        result = actualFieldResolver(source, args, context, info);\n      }\n\n      // Call the stack's handlers either immediately (if result is not a\n      // Promise) or once the Promise is done. Then return that same\n      // maybe-Promise value.\n      whenResultIsFinished(result, handler);\n      return result;\n    } catch (error) {\n      // Normally it's a bad sign to see an error both handled and\n      // re-thrown. But it is useful to allow extensions to track errors while\n      // still handling them in the normal GraphQL way.\n      handler(error);\n      throw error;\n    }\n  };\n}\n\nfunction isPromise(x: any): boolean {\n  return x && typeof x.then === 'function';\n}\n\n// Given result (which may be a Promise or an array some of whose elements are\n// promises) Promises, set up 'callback' to be invoked when result is fully\n// resolved.\nfunction whenResultIsFinished(\n  result: any,\n  callback: (err: Error | null, result?: any) => void,\n) {\n  if (isPromise(result)) {\n    result.then((r: any) => callback(null, r), (err: Error) => callback(err));\n  } else if (Array.isArray(result)) {\n    if (result.some(isPromise)) {\n      Promise.all(result).then(\n        (r: any) => callback(null, r),\n        (err: Error) => callback(err),\n      );\n    } else {\n      callback(null, result);\n    }\n  } else {\n    callback(null, result);\n  }\n}\n\nfunction forEachField(schema: GraphQLSchema, fn: FieldIteratorFn): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(typeName => {\n    const type = typeMap[typeName];\n\n    if (\n      !getNamedType(type).name.startsWith('__') &&\n      type instanceof GraphQLObjectType\n    ) {\n      const fields = type.getFields();\n      Object.keys(fields).forEach(fieldName => {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}\n\nexport type FieldIteratorFn = (\n  fieldDef: GraphQLField<any, any>,\n  typeName: string,\n  fieldName: string,\n) => void;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}