{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cloneObject = exports.processHTTPRequest = exports.runHttpQuery = exports.throwHttpGraphQLError = exports.HttpQueryError = void 0;\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst graphqlOptions_1 = require(\"./graphqlOptions\");\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\nconst requestPipeline_1 = require(\"./requestPipeline\");\nclass HttpQueryError extends Error {\n  constructor(statusCode, message) {\n    let isGraphQLError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let headers = arguments.length > 3 ? arguments[3] : undefined;\n    super(message);\n    this.name = 'HttpQueryError';\n    this.statusCode = statusCode;\n    this.isGraphQLError = isGraphQLError;\n    this.headers = headers;\n  }\n}\nexports.HttpQueryError = HttpQueryError;\nfunction throwHttpGraphQLError(statusCode, errors, options, extensions) {\n  const defaultHeaders = {\n    'Content-Type': 'application/json'\n  };\n  const headers = apollo_server_errors_1.hasPersistedQueryError(errors) ? Object.assign(Object.assign({}, defaultHeaders), {\n    'Cache-Control': 'private, no-cache, must-revalidate'\n  }) : defaultHeaders;\n  const result = {\n    errors: options ? apollo_server_errors_1.formatApolloErrors(errors, {\n      debug: options.debug,\n      formatter: options.formatError\n    }) : errors\n  };\n  if (extensions) {\n    result.extensions = extensions;\n  }\n  throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, headers);\n}\nexports.throwHttpGraphQLError = throwHttpGraphQLError;\nfunction runHttpQuery(handlerArguments, request) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let options;\n    const debugDefault = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';\n    try {\n      options = yield graphqlOptions_1.resolveGraphqlOptions(request.options, ...handlerArguments);\n    } catch (e) {\n      return throwHttpGraphQLError(500, [e], {\n        debug: debugDefault\n      });\n    }\n    if (options.debug === undefined) {\n      options.debug = debugDefault;\n    }\n    if (typeof options.context === 'function') {\n      try {\n        options.context();\n      } catch (e) {\n        e.message = `Context creation failed: ${e.message}`;\n        if (e.extensions && e.extensions.code && e.extensions.code !== 'INTERNAL_SERVER_ERROR') {\n          return throwHttpGraphQLError(400, [e], options);\n        } else {\n          return throwHttpGraphQLError(500, [e], options);\n        }\n      }\n    }\n    const config = {\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      logger: options.logger,\n      rootValue: options.rootValue,\n      context: options.context || {},\n      validationRules: options.validationRules,\n      executor: options.executor,\n      fieldResolver: options.fieldResolver,\n      cache: options.cache,\n      dataSources: options.dataSources,\n      documentStore: options.documentStore,\n      extensions: options.extensions,\n      persistedQueries: options.persistedQueries,\n      tracing: options.tracing,\n      formatError: options.formatError,\n      formatResponse: options.formatResponse,\n      debug: options.debug,\n      plugins: options.plugins || []\n    };\n    return processHTTPRequest(config, request);\n  });\n}\nexports.runHttpQuery = runHttpQuery;\nfunction processHTTPRequest(options, httpRequest) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let requestPayload;\n    switch (httpRequest.method) {\n      case 'POST':\n        if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n          throw new HttpQueryError(500, 'POST body missing. Did you forget use body-parser middleware?');\n        }\n        requestPayload = httpRequest.query;\n        break;\n      case 'GET':\n        if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n          throw new HttpQueryError(400, 'GET query missing.');\n        }\n        requestPayload = httpRequest.query;\n        break;\n      default:\n        throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {\n          Allow: 'GET, POST'\n        });\n    }\n    options = Object.assign(Object.assign({}, options), {\n      plugins: [checkOperationPlugin, ...options.plugins]\n    });\n    function buildRequestContext(request) {\n      const context = cloneObject(options.context);\n      return {\n        logger: options.logger || console,\n        schema: options.schema,\n        schemaHash: options.schemaHash,\n        request,\n        response: {\n          http: {\n            headers: new apollo_server_env_1.Headers()\n          }\n        },\n        context,\n        cache: options.cache,\n        debug: options.debug,\n        metrics: {}\n      };\n    }\n    const responseInit = {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    };\n    let body;\n    try {\n      if (Array.isArray(requestPayload)) {\n        const requests = requestPayload.map(requestParams => parseGraphQLRequest(httpRequest.request, requestParams));\n        const responses = yield Promise.all(requests.map(request => __awaiter(this, void 0, void 0, function* () {\n          try {\n            const requestContext = buildRequestContext(request);\n            return yield requestPipeline_1.processGraphQLRequest(options, requestContext);\n          } catch (error) {\n            return {\n              errors: apollo_server_errors_1.formatApolloErrors([error], options)\n            };\n          }\n        })));\n        body = prettyJSONStringify(responses.map(serializeGraphQLResponse));\n      } else {\n        const request = parseGraphQLRequest(httpRequest.request, requestPayload);\n        try {\n          const requestContext = buildRequestContext(request);\n          const response = yield requestPipeline_1.processGraphQLRequest(options, requestContext);\n          if (response.errors && typeof response.data === 'undefined') {\n            return throwHttpGraphQLError(response.http && response.http.status || 400, response.errors, undefined, response.extensions);\n          }\n          if (response.http) {\n            for (const [name, value] of response.http.headers) {\n              responseInit.headers[name] = value;\n            }\n          }\n          body = prettyJSONStringify(serializeGraphQLResponse(response));\n        } catch (error) {\n          if (error instanceof requestPipeline_1.InvalidGraphQLRequestError) {\n            throw new HttpQueryError(400, error.message);\n          } else if (error instanceof apollo_server_errors_1.PersistedQueryNotSupportedError || error instanceof apollo_server_errors_1.PersistedQueryNotFoundError) {\n            return throwHttpGraphQLError(200, [error], options);\n          } else {\n            throw error;\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof HttpQueryError) {\n        throw error;\n      }\n      return throwHttpGraphQLError(500, [error], options);\n    }\n    responseInit.headers['Content-Length'] = Buffer.byteLength(body, 'utf8').toString();\n    return {\n      graphqlResponse: body,\n      responseInit\n    };\n  });\n}\nexports.processHTTPRequest = processHTTPRequest;\nfunction parseGraphQLRequest(httpRequest, requestParams) {\n  let queryString = requestParams.query;\n  let extensions = requestParams.extensions;\n  if (typeof extensions === 'string' && extensions !== '') {\n    try {\n      extensions = JSON.parse(extensions);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n    }\n  }\n  if (queryString && typeof queryString !== 'string') {\n    if (queryString.kind === 'Document') {\n      throw new HttpQueryError(400, \"GraphQL queries must be strings. It looks like you're sending the \" + 'internal graphql-js representation of a parsed query in your ' + 'request instead of a request in the GraphQL query language. You ' + 'can convert an AST to a string using the `print` function from ' + '`graphql`, or use a client like `apollo-client` which converts ' + 'the internal representation to a string for you.');\n    } else {\n      throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n    }\n  }\n  const operationName = requestParams.operationName;\n  let variables = requestParams.variables;\n  if (typeof variables === 'string' && variables !== '') {\n    try {\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Variables are invalid JSON.');\n    }\n  }\n  return {\n    query: queryString,\n    operationName,\n    variables,\n    extensions,\n    http: httpRequest\n  };\n}\nconst checkOperationPlugin = {\n  requestDidStart() {\n    return {\n      didResolveOperation(_ref) {\n        let {\n          request,\n          operation\n        } = _ref;\n        if (!request.http) return;\n        if (request.http.method === 'GET' && operation.operation !== 'query') {\n          throw new HttpQueryError(405, `GET supports only query operation`, false, {\n            Allow: 'POST'\n          });\n        }\n      }\n    };\n  }\n};\nfunction serializeGraphQLResponse(response) {\n  return {\n    errors: response.errors,\n    data: response.data,\n    extensions: response.extensions\n  };\n}\nfunction prettyJSONStringify(value) {\n  return JSON.stringify(value) + '\\n';\n}\nfunction cloneObject(object) {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\nexports.cloneObject = cloneObject;","map":{"version":3,"names":["apollo_server_env_1","require","graphqlOptions_1","apollo_server_errors_1","requestPipeline_1","HttpQueryError","Error","constructor","statusCode","message","isGraphQLError","arguments","length","undefined","headers","name","exports","throwHttpGraphQLError","errors","options","extensions","defaultHeaders","hasPersistedQueryError","Object","assign","result","formatApolloErrors","debug","formatter","formatError","prettyJSONStringify","runHttpQuery","handlerArguments","request","debugDefault","process","env","NODE_ENV","resolveGraphqlOptions","e","context","code","config","schema","schemaHash","logger","rootValue","validationRules","executor","fieldResolver","cache","dataSources","documentStore","persistedQueries","tracing","formatResponse","plugins","processHTTPRequest","httpRequest","requestPayload","method","query","keys","Allow","checkOperationPlugin","buildRequestContext","cloneObject","console","response","http","Headers","metrics","responseInit","body","Array","isArray","requests","map","requestParams","parseGraphQLRequest","responses","Promise","all","__awaiter","requestContext","processGraphQLRequest","error","serializeGraphQLResponse","data","status","value","InvalidGraphQLRequestError","PersistedQueryNotSupportedError","PersistedQueryNotFoundError","Buffer","byteLength","toString","graphqlResponse","queryString","JSON","parse","kind","operationName","variables","requestDidStart","didResolveOperation","_ref","operation","stringify","object","create","getPrototypeOf"],"sources":["/Users/venusrodin/node_modules/apollo-server-core/src/runHttpQuery.ts"],"sourcesContent":["import { Request, Headers, ValueOrPromise } from 'apollo-server-env';\nimport {\n  default as GraphQLOptions,\n  resolveGraphqlOptions,\n} from './graphqlOptions';\nimport {\n  ApolloError,\n  formatApolloErrors,\n  PersistedQueryNotSupportedError,\n  PersistedQueryNotFoundError,\n  hasPersistedQueryError,\n} from 'apollo-server-errors';\nimport {\n  processGraphQLRequest,\n  GraphQLRequest,\n  InvalidGraphQLRequestError,\n  GraphQLRequestContext,\n  GraphQLResponse,\n} from './requestPipeline';\nimport { ApolloServerPlugin } from 'apollo-server-plugin-base';\nimport { WithRequired, GraphQLExecutionResult } from 'apollo-server-types';\n\nexport interface HttpQueryRequest {\n  method: string;\n  // query is either the POST body or the GET query string map.  In the GET\n  // case, all values are strings and need to be parsed as JSON; in the POST\n  // case they should already be parsed. query has keys like 'query' (whose\n  // value should always be a string), 'variables', 'operationName',\n  // 'extensions', etc.\n  query: Record<string, any> | Array<Record<string, any>>;\n  options:\n    | GraphQLOptions\n    | ((...args: Array<any>) => ValueOrPromise<GraphQLOptions>);\n  request: Pick<Request, 'url' | 'method' | 'headers'>;\n}\n\nexport interface ApolloServerHttpResponse {\n  headers?: Record<string, string>;\n  // ResponseInit contains the follow, which we do not use\n  // status?: number;\n  // statusText?: string;\n}\n\nexport interface HttpQueryResponse {\n  // TODO: This isn't actually an individual GraphQL response, but the body\n  // of the HTTP response, which could contain multiple GraphQL responses\n  // when using batching.\n  graphqlResponse: string;\n  responseInit: ApolloServerHttpResponse;\n}\n\nexport class HttpQueryError extends Error {\n  public statusCode: number;\n  public isGraphQLError: boolean;\n  public headers?: { [key: string]: string };\n\n  constructor(\n    statusCode: number,\n    message: string,\n    isGraphQLError: boolean = false,\n    headers?: { [key: string]: string },\n  ) {\n    super(message);\n    this.name = 'HttpQueryError';\n    this.statusCode = statusCode;\n    this.isGraphQLError = isGraphQLError;\n    this.headers = headers;\n  }\n}\n\n/**\n * If options is specified, then the errors array will be formatted\n */\nexport function throwHttpGraphQLError<E extends Error>(\n  statusCode: number,\n  errors: Array<E>,\n  options?: Pick<GraphQLOptions, 'debug' | 'formatError'>,\n  extensions?: GraphQLExecutionResult['extensions'],\n): never {\n  const defaultHeaders = { 'Content-Type': 'application/json' };\n  // force no-cache on PersistedQuery errors\n  const headers = hasPersistedQueryError(errors)\n    ? {\n        ...defaultHeaders,\n        'Cache-Control': 'private, no-cache, must-revalidate',\n      }\n    : defaultHeaders;\n\n  type Result =\n   & Pick<GraphQLExecutionResult, 'extensions'>\n   & { errors: E[] | ApolloError[] }\n\n  const result: Result = {\n    errors: options\n      ? formatApolloErrors(errors, {\n          debug: options.debug,\n          formatter: options.formatError,\n        })\n      : errors,\n  };\n\n  if (extensions) {\n    result.extensions = extensions;\n  }\n\n  throw new HttpQueryError(\n    statusCode,\n    prettyJSONStringify(result),\n    true,\n    headers,\n  );\n}\n\nexport async function runHttpQuery(\n  handlerArguments: Array<any>,\n  request: HttpQueryRequest,\n): Promise<HttpQueryResponse> {\n  let options: GraphQLOptions;\n  const debugDefault =\n    process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';\n\n  try {\n    options = await resolveGraphqlOptions(request.options, ...handlerArguments);\n  } catch (e) {\n    // The options can be generated asynchronously, so we don't have access to\n    // the normal options provided by the user, such as: formatError,\n    // debug. Therefore, we need to do some unnatural things, such\n    // as use NODE_ENV to determine the debug settings\n    return throwHttpGraphQLError(500, [e], { debug: debugDefault });\n  }\n  if (options.debug === undefined) {\n    options.debug = debugDefault;\n  }\n\n  // TODO: Errors thrown while resolving the context in\n  // ApolloServer#graphQLServerOptions are currently converted to\n  // a throwing function, which we invoke here to rethrow an HTTP error.\n  // When we refactor the integration between ApolloServer, the middleware and\n  // runHttpQuery, we should pass the original context function through,\n  // so we can resolve it on every GraphQL request (as opposed to once per HTTP\n  // request, which could be a batch).\n  if (typeof options.context === 'function') {\n    try {\n      (options.context as () => never)();\n    } catch (e) {\n      e.message = `Context creation failed: ${e.message}`;\n      // For errors that are not internal, such as authentication, we\n      // should provide a 400 response\n      if (\n        e.extensions &&\n        e.extensions.code &&\n        e.extensions.code !== 'INTERNAL_SERVER_ERROR'\n      ) {\n        return throwHttpGraphQLError(400, [e], options);\n      } else {\n        return throwHttpGraphQLError(500, [e], options);\n      }\n    }\n  }\n\n  const config = {\n    schema: options.schema,\n    schemaHash: options.schemaHash,\n    logger: options.logger,\n    rootValue: options.rootValue,\n    context: options.context || {},\n    validationRules: options.validationRules,\n    executor: options.executor,\n    fieldResolver: options.fieldResolver,\n\n    // TODO: Use proper option types to ensure this\n    // The cache is guaranteed to be initialized in ApolloServer, and\n    // cacheControl defaults will also have been set if a boolean argument is\n    // passed in.\n    cache: options.cache!,\n    dataSources: options.dataSources,\n    documentStore: options.documentStore,\n\n    extensions: options.extensions,\n    persistedQueries: options.persistedQueries,\n    tracing: options.tracing,\n\n    formatError: options.formatError,\n    formatResponse: options.formatResponse,\n\n    debug: options.debug,\n\n    plugins: options.plugins || [],\n  };\n\n  return processHTTPRequest(config, request);\n}\n\nexport async function processHTTPRequest<TContext>(\n  options: WithRequired<GraphQLOptions<TContext>, 'cache' | 'plugins'> & {\n    context: TContext;\n  },\n  httpRequest: HttpQueryRequest,\n): Promise<HttpQueryResponse> {\n  let requestPayload;\n\n  switch (httpRequest.method) {\n    case 'POST':\n      if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(\n          500,\n          'POST body missing. Did you forget use body-parser middleware?',\n        );\n      }\n\n      requestPayload = httpRequest.query;\n      break;\n    case 'GET':\n      if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'GET query missing.');\n      }\n\n      requestPayload = httpRequest.query;\n      break;\n\n    default:\n      throw new HttpQueryError(\n        405,\n        'Apollo Server supports only GET/POST requests.',\n        false,\n        {\n          Allow: 'GET, POST',\n        },\n      );\n  }\n\n  // Create a local copy of `options`, based on global options, but maintaining\n  // that appropriate plugins are in place.\n  options = {\n    ...options,\n    plugins: [checkOperationPlugin, ...options.plugins],\n  };\n\n  function buildRequestContext(\n    request: GraphQLRequest,\n  ): GraphQLRequestContext<TContext> {\n    // TODO: We currently shallow clone the context for every request,\n    // but that's unlikely to be what people want.\n    // We allow passing in a function for `context` to ApolloServer,\n    // but this only runs once for a batched request (because this is resolved\n    // in ApolloServer#graphQLServerOptions, before runHttpQuery is invoked).\n    // NOTE: THIS IS DUPLICATED IN ApolloServerBase.prototype.executeOperation.\n    const context = cloneObject(options.context);\n    return {\n      // While `logger` is guaranteed by internal Apollo Server usage of\n      // this `processHTTPRequest` method, this method has been publicly\n      // exported since perhaps as far back as Apollo Server 1.x.  Therefore,\n      // for compatibility reasons, we'll default to `console`.\n      logger: options.logger || console,\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      request,\n      response: {\n        http: {\n          headers: new Headers(),\n        },\n      },\n      context,\n      cache: options.cache,\n      debug: options.debug,\n      metrics: {},\n    };\n  }\n\n  const responseInit: ApolloServerHttpResponse = {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n\n  let body: string;\n\n  try {\n    if (Array.isArray(requestPayload)) {\n      // We're processing a batch request\n      const requests = requestPayload.map(requestParams =>\n        parseGraphQLRequest(httpRequest.request, requestParams),\n      );\n\n      const responses = await Promise.all(\n        requests.map(async request => {\n          try {\n            const requestContext = buildRequestContext(request);\n            return await processGraphQLRequest(options, requestContext);\n          } catch (error) {\n            // A batch can contain another query that returns data,\n            // so we don't error out the entire request with an HttpError\n            return {\n              errors: formatApolloErrors([error], options),\n            };\n          }\n        }),\n      );\n\n      body = prettyJSONStringify(responses.map(serializeGraphQLResponse));\n    } else {\n      // We're processing a normal request\n      const request = parseGraphQLRequest(httpRequest.request, requestPayload);\n\n      try {\n        const requestContext = buildRequestContext(request);\n\n        const response = await processGraphQLRequest(options, requestContext);\n\n        // This code is run on parse/validation errors and any other error that\n        // doesn't reach GraphQL execution\n        if (response.errors && typeof response.data === 'undefined') {\n          // don't include options, since the errors have already been formatted\n          return throwHttpGraphQLError(\n            (response.http && response.http.status) || 400,\n            response.errors as any,\n            undefined,\n            response.extensions,\n          );\n        }\n\n        if (response.http) {\n          for (const [name, value] of response.http.headers) {\n            responseInit.headers![name] = value;\n          }\n        }\n\n        body = prettyJSONStringify(serializeGraphQLResponse(response));\n      } catch (error) {\n        if (error instanceof InvalidGraphQLRequestError) {\n          throw new HttpQueryError(400, error.message);\n        } else if (\n          error instanceof PersistedQueryNotSupportedError ||\n          error instanceof PersistedQueryNotFoundError\n        ) {\n          return throwHttpGraphQLError(200, [error], options);\n        } else {\n          throw error;\n        }\n      }\n    }\n  } catch (error) {\n    if (error instanceof HttpQueryError) {\n      throw error;\n    }\n    return throwHttpGraphQLError(500, [error], options);\n  }\n\n  responseInit.headers!['Content-Length'] = Buffer.byteLength(\n    body,\n    'utf8',\n  ).toString();\n\n  return {\n    graphqlResponse: body,\n    responseInit,\n  };\n}\n\nfunction parseGraphQLRequest(\n  httpRequest: Pick<Request, 'url' | 'method' | 'headers'>,\n  requestParams: Record<string, any>,\n): GraphQLRequest {\n  let queryString: string | undefined = requestParams.query;\n  let extensions = requestParams.extensions;\n\n  if (typeof extensions === 'string' && extensions !== '') {\n    // For GET requests, we have to JSON-parse extensions. (For POST\n    // requests they get parsed as part of parsing the larger body they're\n    // inside.)\n    try {\n      extensions = JSON.parse(extensions);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n    }\n  }\n\n  if (queryString && typeof queryString !== 'string') {\n    // Check for a common error first.\n    if ((queryString as any).kind === 'Document') {\n      throw new HttpQueryError(\n        400,\n        \"GraphQL queries must be strings. It looks like you're sending the \" +\n          'internal graphql-js representation of a parsed query in your ' +\n          'request instead of a request in the GraphQL query language. You ' +\n          'can convert an AST to a string using the `print` function from ' +\n          '`graphql`, or use a client like `apollo-client` which converts ' +\n          'the internal representation to a string for you.',\n      );\n    } else {\n      throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n    }\n  }\n\n  const operationName = requestParams.operationName;\n\n  let variables = requestParams.variables;\n  if (typeof variables === 'string' && variables !== '') {\n    try {\n      // XXX Really we should only do this for GET requests, but for\n      // compatibility reasons we'll keep doing this at least for now for\n      // broken clients that ship variables in a string for no good reason.\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Variables are invalid JSON.');\n    }\n  }\n\n  return {\n    query: queryString,\n    operationName,\n    variables,\n    extensions,\n    http: httpRequest,\n  };\n}\n\n// GET operations should only be queries (not mutations). We want to throw\n// a particular HTTP error in that case.\nconst checkOperationPlugin: ApolloServerPlugin = {\n  requestDidStart() {\n    return {\n      didResolveOperation({ request, operation }) {\n        if (!request.http) return;\n\n        if (request.http.method === 'GET' && operation.operation !== 'query') {\n          throw new HttpQueryError(\n            405,\n            `GET supports only query operation`,\n            false,\n            {\n              Allow: 'POST',\n            },\n          );\n        }\n      },\n    };\n  },\n};\n\nfunction serializeGraphQLResponse(\n  response: GraphQLResponse,\n): Pick<GraphQLResponse, 'errors' | 'data' | 'extensions'> {\n  // See https://github.com/facebook/graphql/pull/384 for why\n  // errors comes first.\n  return {\n    errors: response.errors,\n    data: response.data,\n    extensions: response.extensions,\n  };\n}\n\n// The result of a curl does not appear well in the terminal, so we add an extra new line\nfunction prettyJSONStringify(value: any) {\n  return JSON.stringify(value) + '\\n';\n}\n\nexport function cloneObject<T extends Object>(object: T): T {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}