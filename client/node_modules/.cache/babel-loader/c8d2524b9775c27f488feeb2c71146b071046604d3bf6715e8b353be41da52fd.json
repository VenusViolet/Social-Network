{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar graphql_1 = require(\"graphql\");\n// wraps all resolve functions of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolve funciton\nfunction addSchemaLevelResolveFunction(schema, fn) {\n  // TODO test that schema is a schema, fn is a function\n  var rootTypes = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(function (x) {\n    return !!x;\n  });\n  rootTypes.forEach(function (type) {\n    // XXX this should run at most once per request to simulate a true root resolver\n    // for graphql-js this is an approximation that works with queries but not mutations\n    var rootResolveFn = runAtMostOncePerRequest(fn);\n    var fields = type.getFields();\n    Object.keys(fields).forEach(function (fieldName) {\n      // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n      // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n      if (type === schema.getSubscriptionType()) {\n        fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, fn);\n      } else {\n        fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);\n      }\n    });\n  });\n}\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(innerResolver, outerResolver) {\n  return function (obj, args, ctx, info) {\n    return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\n      if (innerResolver) {\n        return innerResolver(root, args, ctx, info);\n      }\n      return graphql_1.defaultFieldResolver(root, args, ctx, info);\n    });\n  };\n}\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(fn) {\n  var value;\n  var randomNumber = Math.random();\n  return function (root, args, ctx, info) {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n    return value;\n  };\n}\nexports.default = addSchemaLevelResolveFunction;","map":{"version":3,"names":["graphql_1","require","addSchemaLevelResolveFunction","schema","fn","rootTypes","getQueryType","getMutationType","getSubscriptionType","filter","x","forEach","type","rootResolveFn","runAtMostOncePerRequest","fields","getFields","Object","keys","fieldName","resolve","wrapResolver","innerResolver","outerResolver","obj","args","ctx","info","Promise","then","root","defaultFieldResolver","value","randomNumber","Math","random","operation","exports","default"],"sources":["../../src/generate/addSchemaLevelResolveFunction.ts"],"sourcesContent":[null],"mappings":";;;AAAA,IAAAA,SAAA,GAAAC,OAAA;AAMA;AACA;AACA,SAASC,6BAA6BA,CACpCC,MAAqB,EACrBC,EAAkC;EAElC;EACA,IAAMC,SAAS,GAAG,CAChBF,MAAM,CAACG,YAAY,EAAE,EACrBH,MAAM,CAACI,eAAe,EAAE,EACxBJ,MAAM,CAACK,mBAAmB,EAAE,CAC7B,CAACC,MAAM,CAAC,UAAAC,CAAC;IAAI,QAAC,CAACA,CAAC;EAAH,CAAG,CAAC;EAClBL,SAAS,CAACM,OAAO,CAAC,UAAAC,IAAI;IACpB;IACA;IACA,IAAMC,aAAa,GAAGC,uBAAuB,CAACV,EAAE,CAAC;IACjD,IAAMW,MAAM,GAAGH,IAAI,CAACI,SAAS,EAAE;IAC/BC,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC,CAACJ,OAAO,CAAC,UAAAQ,SAAS;MACnC;MACA;MACA,IAAIP,IAAI,KAAKT,MAAM,CAACK,mBAAmB,EAAE,EAAE;QACzCO,MAAM,CAACI,SAAS,CAAC,CAACC,OAAO,GAAGC,YAAY,CAACN,MAAM,CAACI,SAAS,CAAC,CAACC,OAAO,EAAEhB,EAAE,CAAC;OACxE,MAAM;QACLW,MAAM,CAACI,SAAS,CAAC,CAACC,OAAO,GAAGC,YAAY,CACtCN,MAAM,CAACI,SAAS,CAAC,CAACC,OAAO,EACzBP,aAAa,CACd;;IAEL,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA;AACA,SAASQ,YAAYA,CACnBC,aAAyD,EACzDC,aAA6C;EAE7C,OAAO,UAACC,GAAG,EAAEC,IAAI,EAAEC,GAAG,EAAEC,IAAI;IAC1B,OAAOC,OAAO,CAACR,OAAO,CAACG,aAAa,CAACC,GAAG,EAAEC,IAAI,EAAEC,GAAG,EAAEC,IAAI,CAAC,CAAC,CAACE,IAAI,CAAC,UAAAC,IAAI;MACnE,IAAIR,aAAa,EAAE;QACjB,OAAOA,aAAa,CAACQ,IAAI,EAAEL,IAAI,EAAEC,GAAG,EAAEC,IAAI,CAAC;;MAE7C,OAAO3B,SAAA,CAAA+B,oBAAoB,CAACD,IAAI,EAAEL,IAAI,EAAEC,GAAG,EAAEC,IAAI,CAAC;IACpD,CAAC,CAAC;EACJ,CAAC;AACH;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,uBAAuBA,CAC9BV,EAAkC;EAElC,IAAI4B,KAAU;EACd,IAAMC,YAAY,GAAGC,IAAI,CAACC,MAAM,EAAE;EAClC,OAAO,UAACL,IAAI,EAAEL,IAAI,EAAEC,GAAG,EAAEC,IAAI;IAC3B,IAAI,CAACA,IAAI,CAACS,SAAS,CAAC,iBAAiB,CAAC,EAAE;MACtCT,IAAI,CAACS,SAAS,CAAC,iBAAiB,CAAC,GAAG,EAAE;;IAExC,IAAI,CAACT,IAAI,CAACS,SAAS,CAAC,iBAAiB,CAAC,CAACH,YAAY,CAAC,EAAE;MACpDN,IAAI,CAACS,SAAS,CAAC,iBAAiB,CAAC,CAACH,YAAY,CAAC,GAAG,IAAI;MACtDD,KAAK,GAAG5B,EAAE,CAAC0B,IAAI,EAAEL,IAAI,EAAEC,GAAG,EAAEC,IAAI,CAAC;;IAEnC,OAAOK,KAAK;EACd,CAAC;AACH;AAEAK,OAAA,CAAAC,OAAA,GAAepC,6BAA6B"},"metadata":{},"sourceType":"script","externalDependencies":[]}