{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processGraphQLRequest = exports.APQ_CACHE_PREFIX = exports.InvalidGraphQLRequestError = void 0;\nconst graphql_1 = require(\"graphql\");\nconst graphql_extensions_1 = require(\"graphql-extensions\");\nconst schemaInstrumentation_1 = require(\"./utils/schemaInstrumentation\");\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\nconst apollo_server_types_1 = require(\"apollo-server-types\");\nObject.defineProperty(exports, \"InvalidGraphQLRequestError\", {\n  enumerable: true,\n  get: function () {\n    return apollo_server_types_1.InvalidGraphQLRequestError;\n  }\n});\nconst dispatcher_1 = require(\"./utils/dispatcher\");\nconst apollo_server_caching_1 = require(\"apollo-server-caching\");\nconst createSHA_1 = __importDefault(require(\"./utils/createSHA\"));\nconst runHttpQuery_1 = require(\"./runHttpQuery\");\nexports.APQ_CACHE_PREFIX = 'apq:';\nfunction computeQueryHash(query) {\n  return createSHA_1.default('sha256').update(query).digest('hex');\n}\nconst symbolExtensionDeprecationDone = Symbol(\"apolloServerExtensionDeprecationDone\");\nfunction processGraphQLRequest(config, requestContext) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    const logger = requestContext.logger || console;\n    const metrics = requestContext.metrics = requestContext.metrics || Object.create(null);\n    const extensionStack = initializeExtensionStack();\n    requestContext.context._extensionStack = extensionStack;\n    const dispatcher = initializeRequestListenerDispatcher();\n    yield initializeDataSources();\n    const request = requestContext.request;\n    let {\n      query,\n      extensions\n    } = request;\n    let queryHash;\n    let persistedQueryCache;\n    metrics.persistedQueryHit = false;\n    metrics.persistedQueryRegister = false;\n    if (extensions && extensions.persistedQuery) {\n      if (!config.persistedQueries || !config.persistedQueries.cache) {\n        return yield emitErrorAndThrow(new apollo_server_errors_1.PersistedQueryNotSupportedError());\n      } else if (extensions.persistedQuery.version !== 1) {\n        return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('Unsupported persisted query version'));\n      }\n      persistedQueryCache = config.persistedQueries.cache;\n      if (!(persistedQueryCache instanceof apollo_server_caching_1.PrefixingKeyValueCache)) {\n        persistedQueryCache = new apollo_server_caching_1.PrefixingKeyValueCache(persistedQueryCache, exports.APQ_CACHE_PREFIX);\n      }\n      queryHash = extensions.persistedQuery.sha256Hash;\n      if (query === undefined) {\n        query = yield persistedQueryCache.get(queryHash);\n        if (query) {\n          metrics.persistedQueryHit = true;\n        } else {\n          return yield emitErrorAndThrow(new apollo_server_errors_1.PersistedQueryNotFoundError());\n        }\n      } else {\n        const computedQueryHash = computeQueryHash(query);\n        if (queryHash !== computedQueryHash) {\n          return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('provided sha does not match query'));\n        }\n        metrics.persistedQueryRegister = true;\n      }\n    } else if (query) {\n      queryHash = computeQueryHash(query);\n    } else {\n      return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('Must provide query string.'));\n    }\n    requestContext.queryHash = queryHash;\n    requestContext.source = query;\n    yield dispatcher.invokeHookAsync('didResolveSource', requestContext);\n    const requestDidEnd = extensionStack.requestDidStart({\n      request: request.http,\n      queryString: request.query,\n      operationName: request.operationName,\n      variables: request.variables,\n      extensions: request.extensions,\n      context: requestContext.context,\n      persistedQueryHit: metrics.persistedQueryHit,\n      persistedQueryRegister: metrics.persistedQueryRegister,\n      requestContext: requestContext\n    });\n    try {\n      if (config.documentStore) {\n        try {\n          requestContext.document = yield config.documentStore.get(queryHash);\n        } catch (err) {\n          logger.warn('An error occurred while attempting to read from the documentStore. ' + (err && err.message) || err);\n        }\n      }\n      if (!requestContext.document) {\n        const parsingDidEnd = yield dispatcher.invokeDidStartHook('parsingDidStart', requestContext);\n        try {\n          requestContext.document = parse(query, config.parseOptions);\n          parsingDidEnd();\n        } catch (syntaxError) {\n          parsingDidEnd(syntaxError);\n          return yield sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);\n        }\n        const validationDidEnd = yield dispatcher.invokeDidStartHook('validationDidStart', requestContext);\n        const validationErrors = validate(requestContext.document);\n        if (validationErrors.length === 0) {\n          validationDidEnd();\n        } else {\n          validationDidEnd(validationErrors);\n          return yield sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);\n        }\n        if (config.documentStore) {\n          Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch(err => logger.warn('Could not store validated document. ' + (err && err.message) || err));\n        }\n      }\n      const operation = graphql_1.getOperationAST(requestContext.document, request.operationName);\n      requestContext.operation = operation || undefined;\n      requestContext.operationName = operation && operation.name && operation.name.value || null;\n      try {\n        yield dispatcher.invokeHookAsync('didResolveOperation', requestContext);\n      } catch (err) {\n        if (err instanceof runHttpQuery_1.HttpQueryError) {\n          const graphqlError = new graphql_1.GraphQLError(err.message);\n          graphqlError.stack = err.stack;\n          yield didEncounterErrors([graphqlError]);\n          throw err;\n        }\n        return yield sendErrorResponse(err);\n      }\n      if (metrics.persistedQueryRegister && persistedQueryCache) {\n        Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries && typeof config.persistedQueries.ttl !== 'undefined' ? {\n          ttl: config.persistedQueries.ttl\n        } : Object.create(null))).catch(logger.warn);\n      }\n      let response = yield dispatcher.invokeHooksUntilNonNull('responseForOperation', requestContext);\n      if (response == null) {\n        const executionListeners = [];\n        dispatcher.invokeHookSync('executionDidStart', requestContext).forEach(executionListener => {\n          if (typeof executionListener === 'function') {\n            executionListeners.push({\n              executionDidEnd: executionListener\n            });\n          } else if (typeof executionListener === 'object') {\n            executionListeners.push(executionListener);\n          }\n        });\n        const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);\n        const invokeWillResolveField = function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          return executionDispatcher.invokeDidStartHook('willResolveField', ...args);\n        };\n        Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, {\n          value: invokeWillResolveField\n        });\n        if (config.fieldResolver) {\n          Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {\n            value: config.fieldResolver\n          });\n        }\n        schemaInstrumentation_1.enablePluginsForSchemaResolvers(config.schema);\n        try {\n          const result = yield execute(requestContext);\n          const resultErrors = (_a = result.errors) === null || _a === void 0 ? void 0 : _a.map(e => {\n            var _a;\n            if (((_a = e.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 && e.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && e.message.startsWith(`Variable \"$${e.nodes[0].variable.name.value}\" got invalid value `)) {\n              return apollo_server_errors_1.fromGraphQLError(e, {\n                errorClass: apollo_server_errors_1.UserInputError\n              });\n            }\n            return e;\n          });\n          if (resultErrors) {\n            yield didEncounterErrors(resultErrors);\n          }\n          response = Object.assign(Object.assign({}, result), {\n            errors: resultErrors ? formatErrors(resultErrors) : undefined\n          });\n          executionDispatcher.reverseInvokeHookSync('executionDidEnd');\n        } catch (executionError) {\n          executionDispatcher.reverseInvokeHookSync(\"executionDidEnd\", executionError);\n          return yield sendErrorResponse(executionError);\n        }\n      }\n      const formattedExtensions = extensionStack.format();\n      if (Object.keys(formattedExtensions).length > 0) {\n        response.extensions = formattedExtensions;\n      }\n      if (config.formatResponse) {\n        const formattedResponse = config.formatResponse(response, requestContext);\n        if (formattedResponse != null) {\n          response = formattedResponse;\n        }\n      }\n      return sendResponse(response);\n    } finally {\n      requestDidEnd();\n    }\n    function parse(query, parseOptions) {\n      const parsingDidEnd = extensionStack.parsingDidStart({\n        queryString: query\n      });\n      try {\n        return graphql_1.parse(query, parseOptions);\n      } finally {\n        parsingDidEnd();\n      }\n    }\n    function validate(document) {\n      let rules = graphql_1.specifiedRules;\n      if (config.validationRules) {\n        rules = rules.concat(config.validationRules);\n      }\n      const validationDidEnd = extensionStack.validationDidStart();\n      try {\n        return graphql_1.validate(config.schema, document, rules);\n      } finally {\n        validationDidEnd();\n      }\n    }\n    function execute(requestContext) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          request,\n          document\n        } = requestContext;\n        const executionArgs = {\n          schema: config.schema,\n          document,\n          rootValue: typeof config.rootValue === 'function' ? config.rootValue(document) : config.rootValue,\n          contextValue: requestContext.context,\n          variableValues: request.variables,\n          operationName: request.operationName,\n          fieldResolver: config.fieldResolver\n        };\n        const executionDidEnd = extensionStack.executionDidStart({\n          executionArgs\n        });\n        try {\n          if (config.executor) {\n            return yield config.executor(requestContext);\n          } else {\n            return yield graphql_1.execute(executionArgs);\n          }\n        } finally {\n          executionDidEnd();\n        }\n      });\n    }\n    function sendResponse(response) {\n      return __awaiter(this, void 0, void 0, function* () {\n        requestContext.response = extensionStack.willSendResponse({\n          graphqlResponse: Object.assign(Object.assign({}, requestContext.response), {\n            errors: response.errors,\n            data: response.data,\n            extensions: response.extensions\n          }),\n          context: requestContext.context\n        }).graphqlResponse;\n        yield dispatcher.invokeHookAsync('willSendResponse', requestContext);\n        return requestContext.response;\n      });\n    }\n    function emitErrorAndThrow(error) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield didEncounterErrors([error]);\n        throw error;\n      });\n    }\n    function didEncounterErrors(errors) {\n      return __awaiter(this, void 0, void 0, function* () {\n        requestContext.errors = errors;\n        extensionStack.didEncounterErrors(errors);\n        return yield dispatcher.invokeHookAsync('didEncounterErrors', requestContext);\n      });\n    }\n    function sendErrorResponse(errorOrErrors, errorClass) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];\n        yield didEncounterErrors(errors);\n        return sendResponse({\n          errors: formatErrors(errors.map(err => apollo_server_errors_1.fromGraphQLError(err, errorClass && {\n            errorClass\n          })))\n        });\n      });\n    }\n    function formatErrors(errors) {\n      return apollo_server_errors_1.formatApolloErrors(errors, {\n        formatter: config.formatError,\n        debug: requestContext.debug\n      });\n    }\n    function initializeRequestListenerDispatcher() {\n      const requestListeners = [];\n      if (config.plugins) {\n        for (const plugin of config.plugins) {\n          if (!plugin.requestDidStart) continue;\n          const listener = plugin.requestDidStart(requestContext);\n          if (listener) {\n            requestListeners.push(listener);\n          }\n        }\n      }\n      return new dispatcher_1.Dispatcher(requestListeners);\n    }\n    function initializeExtensionStack() {\n      var _a;\n      if ((_a = config.extensions) === null || _a === void 0 ? void 0 : _a.length) {\n        graphql_extensions_1.enableGraphQLExtensions(config.schema);\n      }\n      const extensions = config.extensions ? config.extensions.map(f => f()) : [];\n      const hasOwn = Object.prototype.hasOwnProperty;\n      extensions.forEach(extension => {\n        if (!extension.constructor || hasOwn.call(extension.constructor, symbolExtensionDeprecationDone)) {\n          return;\n        }\n        Object.defineProperty(extension.constructor, symbolExtensionDeprecationDone, {\n          value: true\n        });\n        const extensionName = extension.constructor.name;\n        logger.warn('[deprecated] ' + (extensionName ? 'A \"' + extensionName + '\" ' : 'An anonymous extension ') + 'was defined within the \"extensions\" configuration for ' + 'Apollo Server.  The API on which this extension is built ' + '(\"graphql-extensions\") is being deprecated in the next major ' + 'version of Apollo Server in favor of the new plugin API.  See ' + 'https://go.apollo.dev/s/plugins for the documentation on how ' + 'these plugins are to be defined and used.');\n      });\n      return new graphql_extensions_1.GraphQLExtensionStack(extensions);\n    }\n    function initializeDataSources() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (config.dataSources) {\n          const context = requestContext.context;\n          const dataSources = config.dataSources();\n          const initializers = [];\n          for (const dataSource of Object.values(dataSources)) {\n            if (dataSource.initialize) {\n              initializers.push(dataSource.initialize({\n                context,\n                cache: requestContext.cache\n              }));\n            }\n          }\n          yield Promise.all(initializers);\n          if ('dataSources' in context) {\n            throw new Error('Please use the dataSources config option instead of putting dataSources on the context yourself.');\n          }\n          context.dataSources = dataSources;\n        }\n      });\n    }\n  });\n}\nexports.processGraphQLRequest = processGraphQLRequest;","map":{"version":3,"names":["graphql_1","require","graphql_extensions_1","schemaInstrumentation_1","apollo_server_errors_1","apollo_server_types_1","Object","defineProperty","exports","enumerable","get","InvalidGraphQLRequestError","dispatcher_1","apollo_server_caching_1","createSHA_1","__importDefault","runHttpQuery_1","APQ_CACHE_PREFIX","computeQueryHash","query","default","update","digest","symbolExtensionDeprecationDone","Symbol","processGraphQLRequest","config","requestContext","logger","console","metrics","create","extensionStack","initializeExtensionStack","context","_extensionStack","dispatcher","initializeRequestListenerDispatcher","initializeDataSources","request","extensions","queryHash","persistedQueryCache","persistedQueryHit","persistedQueryRegister","persistedQuery","persistedQueries","cache","emitErrorAndThrow","PersistedQueryNotSupportedError","version","PrefixingKeyValueCache","sha256Hash","undefined","PersistedQueryNotFoundError","computedQueryHash","source","invokeHookAsync","requestDidEnd","requestDidStart","http","queryString","operationName","variables","documentStore","document","err","warn","message","parsingDidEnd","invokeDidStartHook","parse","parseOptions","syntaxError","sendErrorResponse","SyntaxError","validationDidEnd","validationErrors","validate","length","ValidationError","Promise","resolve","set","catch","operation","getOperationAST","name","value","HttpQueryError","graphqlError","GraphQLError","stack","didEncounterErrors","ttl","response","invokeHooksUntilNonNull","executionListeners","invokeHookSync","forEach","executionListener","push","executionDidEnd","executionDispatcher","Dispatcher","invokeWillResolveField","_len","arguments","args","Array","_key","symbolExecutionDispatcherWillResolveField","fieldResolver","symbolUserFieldResolver","enablePluginsForSchemaResolvers","schema","result","execute","resultErrors","_a","errors","map","e","nodes","kind","Kind","VARIABLE_DEFINITION","startsWith","variable","fromGraphQLError","errorClass","UserInputError","assign","formatErrors","reverseInvokeHookSync","executionError","formattedExtensions","format","keys","formatResponse","formattedResponse","sendResponse","parsingDidStart","rules","specifiedRules","validationRules","concat","validationDidStart","executionArgs","rootValue","contextValue","variableValues","executionDidStart","executor","willSendResponse","graphqlResponse","data","error","errorOrErrors","isArray","formatApolloErrors","formatter","formatError","debug","requestListeners","plugins","plugin","listener","enableGraphQLExtensions","f","hasOwn","prototype","hasOwnProperty","extension","constructor","call","extensionName","GraphQLExtensionStack","dataSources","initializers","dataSource","values","initialize","all","Error"],"sources":["/Users/venusrodin/node_modules/apollo-server-core/src/requestPipeline.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  specifiedRules,\n  DocumentNode,\n  getOperationAST,\n  ExecutionArgs,\n  GraphQLError,\n  GraphQLFormattedError,\n  validate as graphqlValidate,\n  parse as graphqlParse,\n  execute as graphqlExecute,\n  Kind,\n} from 'graphql';\nimport {\n  GraphQLExtension,\n  GraphQLExtensionStack,\n  enableGraphQLExtensions,\n} from 'graphql-extensions';\nimport { DataSource } from 'apollo-datasource';\nimport { PersistedQueryOptions } from './graphqlOptions';\nimport {\n  symbolExecutionDispatcherWillResolveField,\n  enablePluginsForSchemaResolvers,\n  symbolUserFieldResolver,\n} from \"./utils/schemaInstrumentation\"\nimport {\n  ApolloError,\n  fromGraphQLError,\n  SyntaxError,\n  ValidationError,\n  PersistedQueryNotSupportedError,\n  PersistedQueryNotFoundError,\n  formatApolloErrors,\n  UserInputError,\n} from 'apollo-server-errors';\nimport {\n  GraphQLRequest,\n  GraphQLResponse,\n  GraphQLRequestContext,\n  GraphQLExecutor,\n  GraphQLExecutionResult,\n  InvalidGraphQLRequestError,\n  ValidationRule,\n  WithRequired,\n} from 'apollo-server-types';\nimport {\n  ApolloServerPlugin,\n  GraphQLRequestListener,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestExecutionListener,\n} from 'apollo-server-plugin-base';\n\nimport { Dispatcher } from './utils/dispatcher';\nimport {\n  InMemoryLRUCache,\n  KeyValueCache,\n  PrefixingKeyValueCache,\n} from 'apollo-server-caching';\nimport { GraphQLParseOptions } from 'graphql-tools';\n\nexport {\n  GraphQLRequest,\n  GraphQLResponse,\n  GraphQLRequestContext,\n  InvalidGraphQLRequestError,\n};\n\nimport createSHA from './utils/createSHA';\nimport { HttpQueryError } from './runHttpQuery';\n\nexport const APQ_CACHE_PREFIX = 'apq:';\n\nfunction computeQueryHash(query: string) {\n  return createSHA('sha256')\n    .update(query)\n    .digest('hex');\n}\n\nexport interface GraphQLRequestPipelineConfig<TContext> {\n  schema: GraphQLSchema;\n\n  rootValue?: ((document: DocumentNode) => any) | any;\n  validationRules?: ValidationRule[];\n  executor?: GraphQLExecutor;\n  fieldResolver?: GraphQLFieldResolver<any, TContext>;\n\n  dataSources?: () => DataSources<TContext>;\n\n  extensions?: Array<() => GraphQLExtension>;\n  persistedQueries?: PersistedQueryOptions;\n\n  formatError?: (error: GraphQLError) => GraphQLFormattedError;\n  formatResponse?: (\n    response: GraphQLResponse,\n    requestContext: GraphQLRequestContext<TContext>,\n  ) => GraphQLResponse | null;\n\n  plugins?: ApolloServerPlugin[];\n  documentStore?: InMemoryLRUCache<DocumentNode>;\n\n  parseOptions?: GraphQLParseOptions;\n}\n\nexport type DataSources<TContext> = {\n  [name: string]: DataSource<TContext>;\n};\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\n/**\n * We attach this symbol to the constructor of extensions to mark that we've\n * already warned about the deprecation of the `graphql-extensions` API for that\n * particular definition.\n */\nconst symbolExtensionDeprecationDone =\n  Symbol(\"apolloServerExtensionDeprecationDone\");\n\nexport async function processGraphQLRequest<TContext>(\n  config: GraphQLRequestPipelineConfig<TContext>,\n  requestContext: Mutable<GraphQLRequestContext<TContext>>,\n): Promise<GraphQLResponse> {\n  // For legacy reasons, this exported method may exist without a `logger` on\n  // the context.  We'll need to make sure we account for that, even though\n  // all of our own machinery will certainly set it now.\n  const logger = requestContext.logger || console;\n\n  // If request context's `metrics` already exists, preserve it, but _ensure_ it\n  // exists there and shorthand it for use throughout this function.\n  const metrics = requestContext.metrics =\n    requestContext.metrics || Object.create(null);\n\n  const extensionStack = initializeExtensionStack();\n  (requestContext.context as any)._extensionStack = extensionStack;\n\n  const dispatcher = initializeRequestListenerDispatcher();\n  await initializeDataSources();\n\n  const request = requestContext.request;\n\n  let { query, extensions } = request;\n\n  let queryHash: string;\n\n  let persistedQueryCache: KeyValueCache | undefined;\n  metrics.persistedQueryHit = false;\n  metrics.persistedQueryRegister = false;\n\n  if (extensions && extensions.persistedQuery) {\n    // It looks like we've received a persisted query. Check if we\n    // support them.\n    if (!config.persistedQueries || !config.persistedQueries.cache) {\n      // We are returning to `runHttpQuery` to preserve legacy behavior while\n      // still delivering observability to the `didEncounterErrors` hook.\n      // This particular error will _not_ trigger `willSendResponse`.\n      // See comment on `emitErrorAndThrow` for more details.\n      return await emitErrorAndThrow(new PersistedQueryNotSupportedError());\n    } else if (extensions.persistedQuery.version !== 1) {\n      // We are returning to `runHttpQuery` to preserve legacy behavior while\n      // still delivering observability to the `didEncounterErrors` hook.\n      // This particular error will _not_ trigger `willSendResponse`.\n      // See comment on `emitErrorAndThrow` for more details.\n      return await emitErrorAndThrow(\n        new InvalidGraphQLRequestError('Unsupported persisted query version'));\n    }\n\n    // We'll store a reference to the persisted query cache so we can actually\n    // do the write at a later point in the request pipeline processing.\n    persistedQueryCache = config.persistedQueries.cache;\n\n    // This is a bit hacky, but if `config` came from direct use of the old\n    // apollo-server 1.0-style middleware (graphqlExpress etc, not via the\n    // ApolloServer class), it won't have been converted to\n    // PrefixingKeyValueCache yet.\n    if (!(persistedQueryCache instanceof PrefixingKeyValueCache)) {\n      persistedQueryCache = new PrefixingKeyValueCache(\n        persistedQueryCache,\n        APQ_CACHE_PREFIX,\n      );\n    }\n\n    queryHash = extensions.persistedQuery.sha256Hash;\n\n    if (query === undefined) {\n      query = await persistedQueryCache.get(queryHash);\n      if (query) {\n        metrics.persistedQueryHit = true;\n      } else {\n        // We are returning to `runHttpQuery` to preserve legacy behavior while\n        // still delivering observability to the `didEncounterErrors` hook.\n        // This particular error will _not_ trigger `willSendResponse`.\n        // See comment on `emitErrorAndThrow` for more details.\n        return await emitErrorAndThrow(new PersistedQueryNotFoundError());\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n\n      // The provided hash must exactly match the SHA-256 hash of\n      // the query string. This prevents hash hijacking, where a\n      // new and potentially malicious query is associated with\n      // an existing hash.\n      if (queryHash !== computedQueryHash) {\n        // We are returning to `runHttpQuery` to preserve legacy behavior while\n        // still delivering observability to the `didEncounterErrors` hook.\n        // This particular error will _not_ trigger `willSendResponse`.\n        // See comment on `emitErrorAndThrow` for more details.\n        return await emitErrorAndThrow(\n          new InvalidGraphQLRequestError('provided sha does not match query'));\n      }\n\n      // We won't write to the persisted query cache until later.\n      // Deferring the writing gives plugins the ability to \"win\" from use of\n      // the cache, but also have their say in whether or not the cache is\n      // written to (by interrupting the request with an error).\n      metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    // TODO: We'll compute the APQ query hash to use as our cache key for\n    // now, but this should be replaced with the new operation ID algorithm.\n    queryHash = computeQueryHash(query);\n  } else {\n    // We are returning to `runHttpQuery` to preserve legacy behavior\n    // while still delivering observability to the `didEncounterErrors` hook.\n    // This particular error will _not_ trigger `willSendResponse`.\n    // See comment on `emitErrorAndThrow` for more details.\n    return await emitErrorAndThrow(\n      new InvalidGraphQLRequestError('Must provide query string.'));\n  }\n\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n\n  // Let the plugins know that we now have a STRING of what we hope will\n  // parse and validate into a document we can execute on.  Unless we have\n  // retrieved this from our APQ cache, there's no guarantee that it is\n  // syntactically correct, so this string should not be trusted as a valid\n  // document until after it's parsed and validated.\n  await dispatcher.invokeHookAsync(\n    'didResolveSource',\n    requestContext as GraphQLRequestContextDidResolveSource<TContext>,\n  );\n\n  const requestDidEnd = extensionStack.requestDidStart({\n    request: request.http!,\n    queryString: request.query,\n    operationName: request.operationName,\n    variables: request.variables,\n    extensions: request.extensions,\n    context: requestContext.context,\n    persistedQueryHit: metrics.persistedQueryHit,\n    persistedQueryRegister: metrics.persistedQueryRegister,\n    requestContext: requestContext as WithRequired<\n      typeof requestContext,\n      'metrics' | 'queryHash'\n    >,\n  });\n\n  try {\n    // If we're configured with a document store (by default, we are), we'll\n    // utilize the operation's hash to lookup the AST from the previously\n    // parsed-and-validated operation.  Failure to retrieve anything from the\n    // cache just means we're committed to doing the parsing and validation.\n    if (config.documentStore) {\n      try {\n        requestContext.document = await config.documentStore.get(queryHash);\n      } catch (err) {\n        logger.warn(\n          'An error occurred while attempting to read from the documentStore. '\n          + (err && err.message) || err,\n        );\n      }\n    }\n\n    // If we still don't have a document, we'll need to parse and validate it.\n    // With success, we'll attempt to save it into the store for future use.\n    if (!requestContext.document) {\n      const parsingDidEnd = await dispatcher.invokeDidStartHook(\n        'parsingDidStart',\n        requestContext as GraphQLRequestContextParsingDidStart<TContext>,\n      );\n\n      try {\n        requestContext.document = parse(query, config.parseOptions);\n        parsingDidEnd();\n      } catch (syntaxError) {\n        parsingDidEnd(syntaxError);\n        return await sendErrorResponse(syntaxError, SyntaxError);\n      }\n\n      const validationDidEnd = await dispatcher.invokeDidStartHook(\n        'validationDidStart',\n        requestContext as GraphQLRequestContextValidationDidStart<TContext>,\n      );\n\n      const validationErrors = validate(requestContext.document);\n\n      if (validationErrors.length === 0) {\n        validationDidEnd();\n      } else {\n        validationDidEnd(validationErrors);\n        return await sendErrorResponse(validationErrors, ValidationError);\n      }\n\n      if (config.documentStore) {\n        // The underlying cache store behind the `documentStore` returns a\n        // `Promise` which is resolved (or rejected), eventually, based on the\n        // success or failure (respectively) of the cache save attempt.  While\n        // it's certainly possible to `await` this `Promise`, we don't care about\n        // whether or not it's successful at this point.  We'll instead proceed\n        // to serve the rest of the request and just hope that this works out.\n        // If it doesn't work, the next request will have another opportunity to\n        // try again.  Errors will surface as warnings, as appropriate.\n        //\n        // While it shouldn't normally be necessary to wrap this `Promise` in a\n        // `Promise.resolve` invocation, it seems that the underlying cache store\n        // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n        Promise.resolve(\n          config.documentStore.set(queryHash, requestContext.document),\n        ).catch(err =>\n          logger.warn(\n            'Could not store validated document. ' +\n            (err && err.message) || err\n          )\n        );\n      }\n    }\n\n    // TODO: If we want to guarantee an operation has been set when invoking\n    // `willExecuteOperation` and executionDidStart`, we need to throw an\n    // error here and not leave this to `buildExecutionContext` in\n    // `graphql-js`.\n    const operation = getOperationAST(\n      requestContext.document,\n      request.operationName,\n    );\n\n    requestContext.operation = operation || undefined;\n    // We'll set `operationName` to `null` for anonymous operations.\n    requestContext.operationName =\n      (operation && operation.name && operation.name.value) || null;\n\n    try {\n      await dispatcher.invokeHookAsync(\n        'didResolveOperation',\n        requestContext as GraphQLRequestContextDidResolveOperation<TContext>,\n      );\n    } catch (err) {\n      // XXX: The HttpQueryError is special-cased here because we currently\n      // depend on `throw`-ing an error from the `didResolveOperation` hook\n      // we've implemented in `runHttpQuery.ts`'s `checkOperationPlugin`:\n      // https://git.io/fj427.  This could be perceived as a feature, but\n      // for the time-being this just maintains existing behavior for what\n      // happens when `throw`-ing an `HttpQueryError` in `didResolveOperation`.\n      if (err instanceof HttpQueryError) {\n        // In order to report this error reliably to the request pipeline, we'll\n        // have to regenerate it with the original error message and stack for\n        // the purposes of the `didEncounterErrors` life-cycle hook (which\n        // expects `GraphQLError`s), but still throw the `HttpQueryError`, so\n        // the appropriate status code is enforced by `runHttpQuery.ts`.\n        const graphqlError = new GraphQLError(err.message);\n        graphqlError.stack = err.stack;\n        await didEncounterErrors([graphqlError]);\n        throw err;\n      }\n      return await sendErrorResponse(err);\n    }\n\n    // Now that we've gone through the pre-execution phases of the request\n    // pipeline, and given plugins appropriate ability to object (by throwing\n    // an error) and not actually write, we'll write to the cache if it was\n    // determined earlier in the request pipeline that we should do so.\n    if (metrics.persistedQueryRegister && persistedQueryCache) {\n      // While it shouldn't normally be necessary to wrap this `Promise` in a\n      // `Promise.resolve` invocation, it seems that the underlying cache store\n      // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n      Promise.resolve(\n        persistedQueryCache.set(\n          queryHash,\n          query,\n          config.persistedQueries &&\n            typeof config.persistedQueries.ttl !== 'undefined'\n            ? {\n                ttl: config.persistedQueries.ttl,\n              }\n            : Object.create(null),\n        ),\n      ).catch(logger.warn);\n    }\n\n    let response: GraphQLResponse | null = await dispatcher.invokeHooksUntilNonNull(\n      'responseForOperation',\n      requestContext as GraphQLRequestContextResponseForOperation<TContext>,\n    );\n    if (response == null) {\n      // This execution dispatcher code is duplicated in `pluginTestHarness`\n      // right now.\n\n      const executionListeners: GraphQLRequestExecutionListener<TContext>[] = [];\n      dispatcher.invokeHookSync(\n        'executionDidStart',\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      ).forEach(executionListener => {\n        if (typeof executionListener === 'function') {\n          executionListeners.push({\n            executionDidEnd: executionListener,\n          });\n        } else if (typeof executionListener === 'object') {\n          executionListeners.push(executionListener);\n        }\n      });\n\n      const executionDispatcher = new Dispatcher(executionListeners);\n\n      // Create a callback that will trigger the execution dispatcher's\n      // `willResolveField` hook.  We will attach this to the context on a\n      // symbol so it can be invoked by our `wrapField` method during execution.\n      const invokeWillResolveField: GraphQLRequestExecutionListener<\n        TContext\n      >['willResolveField'] = (...args) =>\n          executionDispatcher.invokeDidStartHook('willResolveField', ...args);\n\n      Object.defineProperty(\n        requestContext.context,\n        symbolExecutionDispatcherWillResolveField,\n        { value: invokeWillResolveField }\n      );\n\n      // If the user has provided a custom field resolver, we will attach\n      // it to the context so we can still invoke it after we've wrapped the\n      // fields with `wrapField` within `enablePluginsForSchemaResolvers` of\n      // the `schemaInstrumentation` module.\n      if (config.fieldResolver) {\n        Object.defineProperty(\n          requestContext.context,\n          symbolUserFieldResolver,\n          { value: config.fieldResolver }\n        );\n      }\n\n      // If the schema is already enabled, this is a no-op.  Otherwise, the\n      // schema will be augmented so it is able to invoke willResolveField.\n      enablePluginsForSchemaResolvers(config.schema);\n\n      try {\n        const result = await execute(\n          requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n        );\n\n        // The first thing that execution does is coerce the request's variables\n        // to the types declared in the operation, which can lead to errors if\n        // they are of the wrong type. We change any such errors into\n        // UserInputError so that their code doesn't end up being\n        // INTERNAL_SERVER_ERROR, since these are client errors.\n        const resultErrors = result.errors?.map((e) => {\n          if (\n            e.nodes?.length === 1 &&\n            e.nodes[0].kind === Kind.VARIABLE_DEFINITION &&\n            e.message.startsWith(\n              `Variable \"$${e.nodes[0].variable.name.value}\" got invalid value `,\n            )\n          ) {\n            return fromGraphQLError(e, {\n              errorClass: UserInputError,\n            });\n          }\n          return e;\n        });\n\n        if (resultErrors) {\n          await didEncounterErrors(resultErrors);\n        }\n\n        response = {\n          ...result,\n          errors: resultErrors ? formatErrors(resultErrors) : undefined,\n        };\n\n        executionDispatcher.reverseInvokeHookSync('executionDidEnd');\n      } catch (executionError) {\n        executionDispatcher.reverseInvokeHookSync(\"executionDidEnd\", executionError);\n        return await sendErrorResponse(executionError);\n      }\n    }\n\n    const formattedExtensions = extensionStack.format();\n    if (Object.keys(formattedExtensions).length > 0) {\n      response.extensions = formattedExtensions;\n    }\n\n    if (config.formatResponse) {\n      const formattedResponse: GraphQLResponse | null = config.formatResponse(\n        response,\n        requestContext,\n      );\n      if (formattedResponse != null) {\n        response = formattedResponse;\n      }\n    }\n\n    return sendResponse(response);\n  } finally {\n    requestDidEnd();\n  }\n\n  function parse(\n    query: string,\n    parseOptions?: GraphQLParseOptions,\n  ): DocumentNode {\n    const parsingDidEnd = extensionStack.parsingDidStart({\n      queryString: query,\n    });\n\n    try {\n      return graphqlParse(query, parseOptions);\n    } finally {\n      parsingDidEnd();\n    }\n  }\n\n  function validate(document: DocumentNode): ReadonlyArray<GraphQLError> {\n    let rules = specifiedRules;\n    if (config.validationRules) {\n      rules = rules.concat(config.validationRules);\n    }\n\n    const validationDidEnd = extensionStack.validationDidStart();\n\n    try {\n      return graphqlValidate(config.schema, document, rules);\n    } finally {\n      validationDidEnd();\n    }\n  }\n\n  async function execute(\n    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  ): Promise<GraphQLExecutionResult> {\n    const { request, document } = requestContext;\n\n    const executionArgs: ExecutionArgs = {\n      schema: config.schema,\n      document,\n      rootValue:\n        typeof config.rootValue === 'function'\n          ? config.rootValue(document)\n          : config.rootValue,\n      contextValue: requestContext.context,\n      variableValues: request.variables,\n      operationName: request.operationName,\n      fieldResolver: config.fieldResolver,\n    };\n\n    const executionDidEnd = extensionStack.executionDidStart({\n      executionArgs,\n    });\n\n    try {\n      if (config.executor) {\n        // XXX Nothing guarantees that the only errors thrown or returned\n        // in result.errors are GraphQLErrors, even though other code\n        // (eg ApolloServerPluginUsageReporting) assumes that.\n        return await config.executor(requestContext);\n      } else {\n        return await graphqlExecute(executionArgs);\n      }\n    } finally {\n      executionDidEnd();\n    }\n  }\n\n  async function sendResponse(\n    response: GraphQLResponse,\n  ): Promise<GraphQLResponse> {\n    // We override errors, data, and extensions with the passed in response,\n    // but keep other properties (like http)\n    requestContext.response = extensionStack.willSendResponse({\n      graphqlResponse: {\n        ...requestContext.response,\n        errors: response.errors,\n        data: response.data,\n        extensions: response.extensions,\n      },\n      context: requestContext.context,\n    }).graphqlResponse;\n    await dispatcher.invokeHookAsync(\n      'willSendResponse',\n      requestContext as GraphQLRequestContextWillSendResponse<TContext>,\n    );\n    return requestContext.response!;\n  }\n\n  /**\n   * HEREIN LIE LEGACY COMPATIBILITY\n   *\n   * DO NOT PERPETUATE THE USE OF THIS METHOD IN NEWLY INTRODUCED CODE.\n   *\n   * Report an error via `didEncounterErrors` and then `throw` it again,\n   * ENTIRELY BYPASSING the rest of the request pipeline and returning\n   * control to `runHttpQuery.ts`.\n   *\n   * Any number of other life-cycle events may not be invoked in this case.\n   *\n   * Prior to the introduction of this function, some errors were being thrown\n   * within the request pipeline and going directly to handling within\n   * the `runHttpQuery.ts` module, rather than first being reported to the\n   * plugin API's `didEncounterErrors` life-cycle hook (where they are to be\n   * expected!).\n   *\n   * @param error The error to report to the request pipeline plugins prior\n   *              to being thrown.\n   *\n   * @throws\n   *\n   */\n  async function emitErrorAndThrow(error: GraphQLError): Promise<never> {\n    await didEncounterErrors([error]);\n    throw error;\n  }\n\n  async function didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {\n    requestContext.errors = errors;\n    extensionStack.didEncounterErrors(errors);\n\n    return await dispatcher.invokeHookAsync(\n      'didEncounterErrors',\n      requestContext as GraphQLRequestContextDidEncounterErrors<TContext>,\n    );\n  }\n\n  async function sendErrorResponse(\n    errorOrErrors: ReadonlyArray<GraphQLError> | GraphQLError,\n    errorClass?: typeof ApolloError,\n  ) {\n    // If a single error is passed, it should still be encapsulated in an array.\n    const errors = Array.isArray(errorOrErrors)\n      ? errorOrErrors\n      : [errorOrErrors];\n\n    await didEncounterErrors(errors);\n\n    return sendResponse({\n      errors: formatErrors(\n        errors.map(err =>\n          fromGraphQLError(\n            err,\n            errorClass && {\n              errorClass,\n            },\n          ),\n        ),\n      ),\n    });\n  }\n\n  function formatErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReadonlyArray<GraphQLFormattedError> {\n    return formatApolloErrors(errors, {\n      formatter: config.formatError,\n      debug: requestContext.debug,\n    });\n  }\n\n  function initializeRequestListenerDispatcher(): Dispatcher<\n    GraphQLRequestListener<TContext>\n  > {\n    const requestListeners: GraphQLRequestListener<TContext>[] = [];\n    if (config.plugins) {\n      for (const plugin of config.plugins) {\n        if (!plugin.requestDidStart) continue;\n        const listener = plugin.requestDidStart(requestContext);\n        if (listener) {\n          requestListeners.push(listener);\n        }\n      }\n    }\n    return new Dispatcher(requestListeners);\n  }\n\n  function initializeExtensionStack(): GraphQLExtensionStack<TContext> {\n    if (config.extensions?.length) {\n      // graphql-extensions adds some overhead to field resolvers.\n      // Only enable extensions when at least 1 extension has been provided\n      enableGraphQLExtensions(config.schema);\n    }\n\n    // If custom extension factories were provided, create per-request extension\n    // objects.\n    const extensions = config.extensions ? config.extensions.map(f => f()) : [];\n\n    // Warn about usage of (deprecated) `graphql-extensions` implementations.\n    // Since extensions are often provided as factory functions which\n    // instantiate an extension on each request, we'll attach a symbol to the\n    // constructor after we've warned to ensure that we don't do it on each\n    // request.  Another option here might be to keep a `Map` of constructor\n    // instances within this module, but I hope this will do the trick.\n    const hasOwn = Object.prototype.hasOwnProperty;\n    extensions.forEach((extension) => {\n      // Using `hasOwn` just in case there is a user-land `hasOwnProperty`\n      // defined on the `constructor` object.\n      if (\n        !extension.constructor ||\n        hasOwn.call(extension.constructor, symbolExtensionDeprecationDone)\n      ) {\n        return;\n      }\n\n      Object.defineProperty(\n        extension.constructor,\n        symbolExtensionDeprecationDone,\n        { value: true }\n      );\n\n      const extensionName = extension.constructor.name;\n      logger.warn(\n        '[deprecated] ' +\n          (extensionName\n            ? 'A \"' + extensionName + '\" '\n            : 'An anonymous extension ') +\n          'was defined within the \"extensions\" configuration for ' +\n          'Apollo Server.  The API on which this extension is built ' +\n          '(\"graphql-extensions\") is being deprecated in the next major ' +\n          'version of Apollo Server in favor of the new plugin API.  See ' +\n          'https://go.apollo.dev/s/plugins for the documentation on how ' +\n          'these plugins are to be defined and used.',\n      );\n    });\n\n    return new GraphQLExtensionStack(extensions);\n  }\n\n  async function initializeDataSources() {\n    if (config.dataSources) {\n      const context = requestContext.context;\n\n      const dataSources = config.dataSources();\n\n      const initializers: any[] = [];\n      for (const dataSource of Object.values(dataSources)) {\n        if (dataSource.initialize) {\n          initializers.push(\n            dataSource.initialize({\n              context,\n              cache: requestContext.cache,\n            })\n          );\n        }\n      }\n\n      await Promise.all(initializers);\n\n      if ('dataSources' in context) {\n        throw new Error(\n          'Please use the dataSources config option instead of putting dataSources on the context yourself.',\n        );\n      }\n\n      (context as any).dataSources = dataSources;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}