{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.__testing__ = exports.plugin = exports.CacheScope = void 0;\nconst graphql_1 = require(\"graphql\");\nvar CacheScope;\n(function (CacheScope) {\n  CacheScope[\"Public\"] = \"PUBLIC\";\n  CacheScope[\"Private\"] = \"PRIVATE\";\n})(CacheScope = exports.CacheScope || (exports.CacheScope = {}));\nexports.plugin = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.create(null);\n  return {\n    requestDidStart(requestContext) {\n      const defaultMaxAge = options.defaultMaxAge || 0;\n      const hints = new Map();\n      function setOverallCachePolicyWhenUnset() {\n        if (!requestContext.overallCachePolicy) {\n          requestContext.overallCachePolicy = computeOverallCachePolicy(hints);\n        }\n      }\n      return {\n        executionDidStart: () => ({\n          executionDidEnd: () => setOverallCachePolicyWhenUnset(),\n          willResolveField(_ref) {\n            let {\n              info\n            } = _ref;\n            let hint = {};\n            const targetType = graphql_1.getNamedType(info.returnType);\n            if (targetType instanceof graphql_1.GraphQLObjectType || targetType instanceof graphql_1.GraphQLInterfaceType) {\n              if (targetType.astNode) {\n                hint = mergeHints(hint, cacheHintFromDirectives(targetType.astNode.directives));\n              }\n            }\n            const fieldDef = info.parentType.getFields()[info.fieldName];\n            if (fieldDef.astNode) {\n              hint = mergeHints(hint, cacheHintFromDirectives(fieldDef.astNode.directives));\n            }\n            if ((targetType instanceof graphql_1.GraphQLObjectType || targetType instanceof graphql_1.GraphQLInterfaceType || !info.path.prev) && hint.maxAge === undefined) {\n              hint.maxAge = defaultMaxAge;\n            }\n            if (hint.maxAge !== undefined || hint.scope !== undefined) {\n              addHint(hints, info.path, hint);\n            }\n            info.cacheControl = {\n              setCacheHint: hint => {\n                addHint(hints, info.path, hint);\n              },\n              cacheHint: hint\n            };\n          }\n        }),\n        responseForOperation() {\n          setOverallCachePolicyWhenUnset();\n          return null;\n        },\n        willSendResponse(requestContext) {\n          const {\n            response,\n            overallCachePolicy: overallCachePolicyOverride\n          } = requestContext;\n          if (response.errors) {\n            return;\n          }\n          const overallCachePolicy = overallCachePolicyOverride || (requestContext.overallCachePolicy = computeOverallCachePolicy(hints));\n          if (overallCachePolicy && options.calculateHttpHeaders && response.http) {\n            response.http.headers.set('Cache-Control', `max-age=${overallCachePolicy.maxAge}, ${overallCachePolicy.scope.toLowerCase()}`);\n          }\n          if (options.stripFormattedExtensions !== false) return;\n          const extensions = response.extensions || (response.extensions = Object.create(null));\n          if (typeof extensions.cacheControl !== 'undefined') {\n            throw new Error(\"The cacheControl information already existed.\");\n          }\n          extensions.cacheControl = {\n            version: 1,\n            hints: Array.from(hints).map(_ref2 => {\n              let [path, hint] = _ref2;\n              return Object.assign({\n                path: [...graphql_1.responsePathAsArray(path)]\n              }, hint);\n            })\n          };\n        }\n      };\n    }\n  };\n};\nfunction cacheHintFromDirectives(directives) {\n  if (!directives) return undefined;\n  const cacheControlDirective = directives.find(directive => directive.name.value === 'cacheControl');\n  if (!cacheControlDirective) return undefined;\n  if (!cacheControlDirective.arguments) return undefined;\n  const maxAgeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'maxAge');\n  const scopeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'scope');\n  return {\n    maxAge: maxAgeArgument && maxAgeArgument.value && maxAgeArgument.value.kind === 'IntValue' ? parseInt(maxAgeArgument.value.value) : undefined,\n    scope: scopeArgument && scopeArgument.value && scopeArgument.value.kind === 'EnumValue' ? scopeArgument.value.value : undefined\n  };\n}\nfunction mergeHints(hint, otherHint) {\n  if (!otherHint) return hint;\n  return {\n    maxAge: otherHint.maxAge !== undefined ? otherHint.maxAge : hint.maxAge,\n    scope: otherHint.scope || hint.scope\n  };\n}\nfunction computeOverallCachePolicy(hints) {\n  let lowestMaxAge = undefined;\n  let scope = CacheScope.Public;\n  for (const hint of hints.values()) {\n    if (hint.maxAge !== undefined) {\n      lowestMaxAge = lowestMaxAge !== undefined ? Math.min(lowestMaxAge, hint.maxAge) : hint.maxAge;\n    }\n    if (hint.scope === CacheScope.Private) {\n      scope = CacheScope.Private;\n    }\n  }\n  return lowestMaxAge ? {\n    maxAge: lowestMaxAge,\n    scope\n  } : undefined;\n}\nfunction addHint(hints, path, hint) {\n  const existingCacheHint = hints.get(path);\n  if (existingCacheHint) {\n    hints.set(path, mergeHints(existingCacheHint, hint));\n  } else {\n    hints.set(path, hint);\n  }\n}\nexports.__testing__ = {\n  addHint,\n  computeOverallCachePolicy\n};","map":{"version":3,"names":["graphql_1","require","CacheScope","exports","plugin","options","arguments","length","undefined","Object","create","requestDidStart","requestContext","defaultMaxAge","hints","Map","setOverallCachePolicyWhenUnset","overallCachePolicy","computeOverallCachePolicy","executionDidStart","executionDidEnd","willResolveField","_ref","info","hint","targetType","getNamedType","returnType","GraphQLObjectType","GraphQLInterfaceType","astNode","mergeHints","cacheHintFromDirectives","directives","fieldDef","parentType","getFields","fieldName","path","prev","maxAge","scope","addHint","cacheControl","setCacheHint","cacheHint","responseForOperation","willSendResponse","response","overallCachePolicyOverride","errors","calculateHttpHeaders","http","headers","set","toLowerCase","stripFormattedExtensions","extensions","Error","version","Array","from","map","_ref2","assign","responsePathAsArray","cacheControlDirective","find","directive","name","value","maxAgeArgument","argument","scopeArgument","kind","parseInt","otherHint","lowestMaxAge","Public","values","Math","min","Private","existingCacheHint","get","__testing__"],"sources":["/Users/venusrodin/node_modules/apollo-cache-control/src/index.ts"],"sourcesContent":["import {\n  DirectiveNode,\n  getNamedType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  ResponsePath,\n  responsePathAsArray,\n} from 'graphql';\nimport { ApolloServerPlugin } from \"apollo-server-plugin-base\";\n\nexport interface CacheControlFormat {\n  version: 1;\n  hints: ({ path: (string | number)[] } & CacheHint)[];\n}\n\nexport interface CacheHint {\n  maxAge?: number;\n  scope?: CacheScope;\n}\n\nexport enum CacheScope {\n  Public = 'PUBLIC',\n  Private = 'PRIVATE',\n}\n\nexport interface CacheControlExtensionOptions {\n  defaultMaxAge?: number;\n  // TODO: We should replace these with\n  // more appropriately named options.\n  calculateHttpHeaders?: boolean;\n  stripFormattedExtensions?: boolean;\n}\n\ndeclare module 'graphql/type/definition' {\n  interface GraphQLResolveInfo {\n    cacheControl: {\n      setCacheHint: (hint: CacheHint) => void;\n      cacheHint: CacheHint;\n    };\n  }\n}\n\ndeclare module 'apollo-server-types' {\n  interface GraphQLRequestContext<TContext> {\n    // Not readonly: plugins can set it.\n    overallCachePolicy?: Required<CacheHint> | undefined;\n  }\n}\n\ntype MapResponsePathHints = Map<ResponsePath, CacheHint>;\n\nexport const plugin = (\n  options: CacheControlExtensionOptions = Object.create(null),\n): ApolloServerPlugin => ({\n  requestDidStart(requestContext) {\n    const defaultMaxAge: number = options.defaultMaxAge || 0;\n    const hints: MapResponsePathHints = new Map();\n\n\n    function setOverallCachePolicyWhenUnset() {\n      if (!requestContext.overallCachePolicy) {\n        requestContext.overallCachePolicy = computeOverallCachePolicy(hints);\n      }\n    }\n\n    return {\n      executionDidStart: () => ({\n        executionDidEnd: () => setOverallCachePolicyWhenUnset(),\n        willResolveField({ info }) {\n          let hint: CacheHint = {};\n\n          // If this field's resolver returns an object or interface, look for\n          // hints on that return type.\n          const targetType = getNamedType(info.returnType);\n          if (\n            targetType instanceof GraphQLObjectType ||\n            targetType instanceof GraphQLInterfaceType\n          ) {\n            if (targetType.astNode) {\n              hint = mergeHints(\n                hint,\n                cacheHintFromDirectives(targetType.astNode.directives),\n              );\n            }\n          }\n\n          // Look for hints on the field itself (on its parent type), taking\n          // precedence over previously calculated hints.\n          const fieldDef = info.parentType.getFields()[info.fieldName];\n          if (fieldDef.astNode) {\n            hint = mergeHints(\n              hint,\n              cacheHintFromDirectives(fieldDef.astNode.directives),\n            );\n          }\n\n          // If this resolver returns an object or is a root field and we haven't\n          // seen an explicit maxAge hint, set the maxAge to 0 (uncached) or the\n          // default if specified in the constructor. (Non-object fields by\n          // default are assumed to inherit their cacheability from their parents.\n          // But on the other hand, while root non-object fields can get explicit\n          // hints from their definition on the Query/Mutation object, if that\n          // doesn't exist then there's no parent field that would assign the\n          // default maxAge, so we do it here.)\n          if (\n            (targetType instanceof GraphQLObjectType ||\n              targetType instanceof GraphQLInterfaceType ||\n              !info.path.prev) &&\n            hint.maxAge === undefined\n          ) {\n            hint.maxAge = defaultMaxAge;\n          }\n\n          if (hint.maxAge !== undefined || hint.scope !== undefined) {\n            addHint(hints, info.path, hint);\n          }\n\n          info.cacheControl = {\n            setCacheHint: (hint: CacheHint) => {\n              addHint(hints, info.path, hint);\n            },\n            cacheHint: hint,\n          };\n        },\n      }),\n\n      responseForOperation() {\n        // We are not supplying an answer, we are only setting the cache\n        // policy if it's not set! Therefore, we return null.\n        setOverallCachePolicyWhenUnset();\n        return null;\n      },\n\n      willSendResponse(requestContext) {\n        const {\n          response,\n          overallCachePolicy: overallCachePolicyOverride,\n        } = requestContext;\n\n        // If there are any errors, we don't consider this cacheable.\n        if (response.errors) {\n          return;\n        }\n\n        // Use the override by default, but if it's not overridden, set our\n        // own computation onto the `requestContext` for other plugins to read.\n        const overallCachePolicy =\n          overallCachePolicyOverride ||\n          (requestContext.overallCachePolicy =\n            computeOverallCachePolicy(hints));\n\n        if (\n          overallCachePolicy &&\n          options.calculateHttpHeaders &&\n          response.http\n        ) {\n          response.http.headers.set(\n            'Cache-Control',\n            `max-age=${\n              overallCachePolicy.maxAge\n            }, ${overallCachePolicy.scope.toLowerCase()}`,\n          );\n        }\n\n        // We should have to explicitly ask to leave the formatted extension in,\n        // or pass the old-school `cacheControl: true` (as interpreted by\n        // apollo-server-core/ApolloServer), in order to include the\n        // old engineproxy-aimed extensions. Specifically, we want users of\n        // apollo-server-plugin-response-cache to be able to specify\n        // `cacheControl: {defaultMaxAge: 600}` without accidentally turning on\n        // the extension formatting.\n        if (options.stripFormattedExtensions !== false) return;\n\n        const extensions =\n          response.extensions || (response.extensions = Object.create(null));\n\n        if (typeof extensions.cacheControl !== 'undefined') {\n          throw new Error(\"The cacheControl information already existed.\");\n        }\n\n        extensions.cacheControl = {\n          version: 1,\n          hints: Array.from(hints).map(([path, hint]) => ({\n            path: [...responsePathAsArray(path)],\n            ...hint,\n          })),\n        };\n      }\n    }\n  }\n});\n\nfunction cacheHintFromDirectives(\n  directives: ReadonlyArray<DirectiveNode> | undefined,\n): CacheHint | undefined {\n  if (!directives) return undefined;\n\n  const cacheControlDirective = directives.find(\n    directive => directive.name.value === 'cacheControl',\n  );\n  if (!cacheControlDirective) return undefined;\n\n  if (!cacheControlDirective.arguments) return undefined;\n\n  const maxAgeArgument = cacheControlDirective.arguments.find(\n    argument => argument.name.value === 'maxAge',\n  );\n  const scopeArgument = cacheControlDirective.arguments.find(\n    argument => argument.name.value === 'scope',\n  );\n\n  // TODO: Add proper typechecking of arguments\n  return {\n    maxAge:\n      maxAgeArgument &&\n      maxAgeArgument.value &&\n      maxAgeArgument.value.kind === 'IntValue'\n        ? parseInt(maxAgeArgument.value.value)\n        : undefined,\n    scope:\n      scopeArgument &&\n      scopeArgument.value &&\n      scopeArgument.value.kind === 'EnumValue'\n        ? (scopeArgument.value.value as CacheScope)\n        : undefined,\n  };\n}\n\nfunction mergeHints(\n  hint: CacheHint,\n  otherHint: CacheHint | undefined,\n): CacheHint {\n  if (!otherHint) return hint;\n\n  return {\n    maxAge: otherHint.maxAge !== undefined ? otherHint.maxAge : hint.maxAge,\n    scope: otherHint.scope || hint.scope,\n  };\n}\n\nfunction computeOverallCachePolicy(\n  hints: MapResponsePathHints,\n): Required<CacheHint> | undefined {\n  let lowestMaxAge: number | undefined = undefined;\n  let scope: CacheScope = CacheScope.Public;\n\n  for (const hint of hints.values()) {\n    if (hint.maxAge !== undefined) {\n      lowestMaxAge =\n        lowestMaxAge !== undefined\n          ? Math.min(lowestMaxAge, hint.maxAge)\n          : hint.maxAge;\n    }\n    if (hint.scope === CacheScope.Private) {\n      scope = CacheScope.Private;\n    }\n  }\n\n  // If maxAge is 0, then we consider it uncacheable so it doesn't matter what\n  // the scope was.\n  return lowestMaxAge\n    ? {\n        maxAge: lowestMaxAge,\n        scope,\n      }\n    : undefined;\n}\n\nfunction addHint(hints: MapResponsePathHints, path: ResponsePath, hint: CacheHint) {\n  const existingCacheHint = hints.get(path);\n  if (existingCacheHint) {\n    hints.set(path, mergeHints(existingCacheHint, hint));\n  } else {\n    hints.set(path, hint);\n  }\n}\n\nexport const __testing__ = {\n  addHint,\n  computeOverallCachePolicy,\n};\n"],"mappings":";;;;;;AAAA,MAAAA,SAAA,GAAAC,OAAA;AAoBA,IAAYC,UAGX;AAHD,WAAYA,UAAU;EACpBA,UAAA,qBAAiB;EACjBA,UAAA,uBAAmB;AACrB,CAAC,EAHWA,UAAU,GAAVC,OAAA,CAAAD,UAAU,KAAVC,OAAA,CAAAD,UAAU;AA+BTC,OAAA,CAAAC,MAAM,GAAG;EAAA,IACpBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAwCG,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAAA,OACnC;IACxBC,eAAeA,CAACC,cAAc;MAC5B,MAAMC,aAAa,GAAWR,OAAO,CAACQ,aAAa,IAAI,CAAC;MACxD,MAAMC,KAAK,GAAyB,IAAIC,GAAG,EAAE;MAG7C,SAASC,8BAA8BA,CAAA;QACrC,IAAI,CAACJ,cAAc,CAACK,kBAAkB,EAAE;UACtCL,cAAc,CAACK,kBAAkB,GAAGC,yBAAyB,CAACJ,KAAK,CAAC;;MAExE;MAEA,OAAO;QACLK,iBAAiB,EAAEA,CAAA,MAAO;UACxBC,eAAe,EAAEA,CAAA,KAAMJ,8BAA8B,EAAE;UACvDK,gBAAgBA,CAAAC,IAAA,EAAS;YAAA,IAAR;cAAEC;YAAI,CAAE,GAAAD,IAAA;YACvB,IAAIE,IAAI,GAAc,EAAE;YAIxB,MAAMC,UAAU,GAAGzB,SAAA,CAAA0B,YAAY,CAACH,IAAI,CAACI,UAAU,CAAC;YAChD,IACEF,UAAU,YAAYzB,SAAA,CAAA4B,iBAAiB,IACvCH,UAAU,YAAYzB,SAAA,CAAA6B,oBAAoB,EAC1C;cACA,IAAIJ,UAAU,CAACK,OAAO,EAAE;gBACtBN,IAAI,GAAGO,UAAU,CACfP,IAAI,EACJQ,uBAAuB,CAACP,UAAU,CAACK,OAAO,CAACG,UAAU,CAAC,CACvD;;;YAML,MAAMC,QAAQ,GAAGX,IAAI,CAACY,UAAU,CAACC,SAAS,EAAE,CAACb,IAAI,CAACc,SAAS,CAAC;YAC5D,IAAIH,QAAQ,CAACJ,OAAO,EAAE;cACpBN,IAAI,GAAGO,UAAU,CACfP,IAAI,EACJQ,uBAAuB,CAACE,QAAQ,CAACJ,OAAO,CAACG,UAAU,CAAC,CACrD;;YAWH,IACE,CAACR,UAAU,YAAYzB,SAAA,CAAA4B,iBAAiB,IACtCH,UAAU,YAAYzB,SAAA,CAAA6B,oBAAoB,IAC1C,CAACN,IAAI,CAACe,IAAI,CAACC,IAAI,KACjBf,IAAI,CAACgB,MAAM,KAAKhC,SAAS,EACzB;cACAgB,IAAI,CAACgB,MAAM,GAAG3B,aAAa;;YAG7B,IAAIW,IAAI,CAACgB,MAAM,KAAKhC,SAAS,IAAIgB,IAAI,CAACiB,KAAK,KAAKjC,SAAS,EAAE;cACzDkC,OAAO,CAAC5B,KAAK,EAAES,IAAI,CAACe,IAAI,EAAEd,IAAI,CAAC;;YAGjCD,IAAI,CAACoB,YAAY,GAAG;cAClBC,YAAY,EAAGpB,IAAe,IAAI;gBAChCkB,OAAO,CAAC5B,KAAK,EAAES,IAAI,CAACe,IAAI,EAAEd,IAAI,CAAC;cACjC,CAAC;cACDqB,SAAS,EAAErB;aACZ;UACH;SACD,CAAC;QAEFsB,oBAAoBA,CAAA;UAGlB9B,8BAA8B,EAAE;UAChC,OAAO,IAAI;QACb,CAAC;QAED+B,gBAAgBA,CAACnC,cAAc;UAC7B,MAAM;YACJoC,QAAQ;YACR/B,kBAAkB,EAAEgC;UAA0B,CAC/C,GAAGrC,cAAc;UAGlB,IAAIoC,QAAQ,CAACE,MAAM,EAAE;YACnB;;UAKF,MAAMjC,kBAAkB,GACtBgC,0BAA0B,KACzBrC,cAAc,CAACK,kBAAkB,GAChCC,yBAAyB,CAACJ,KAAK,CAAC,CAAC;UAErC,IACEG,kBAAkB,IAClBZ,OAAO,CAAC8C,oBAAoB,IAC5BH,QAAQ,CAACI,IAAI,EACb;YACAJ,QAAQ,CAACI,IAAI,CAACC,OAAO,CAACC,GAAG,CACvB,eAAe,EACf,WACErC,kBAAkB,CAACuB,MACrB,KAAKvB,kBAAkB,CAACwB,KAAK,CAACc,WAAW,EAAE,EAAE,CAC9C;;UAUH,IAAIlD,OAAO,CAACmD,wBAAwB,KAAK,KAAK,EAAE;UAEhD,MAAMC,UAAU,GACdT,QAAQ,CAACS,UAAU,KAAKT,QAAQ,CAACS,UAAU,GAAGhD,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC,CAAC;UAEpE,IAAI,OAAO+C,UAAU,CAACd,YAAY,KAAK,WAAW,EAAE;YAClD,MAAM,IAAIe,KAAK,CAAC,+CAA+C,CAAC;;UAGlED,UAAU,CAACd,YAAY,GAAG;YACxBgB,OAAO,EAAE,CAAC;YACV7C,KAAK,EAAE8C,KAAK,CAACC,IAAI,CAAC/C,KAAK,CAAC,CAACgD,GAAG,CAACC,KAAA;cAAA,IAAC,CAACzB,IAAI,EAAEd,IAAI,CAAC,GAAAuC,KAAA;cAAA,OAAKtD,MAAA,CAAAuD,MAAA;gBAC7C1B,IAAI,EAAE,CAAC,GAAGtC,SAAA,CAAAiE,mBAAmB,CAAC3B,IAAI,CAAC;cAAC,GACjCd,IAAI;YAAA,CACP;WACH;QACH;OACD;IACH;GACD;AAAA,CAAC;AAEF,SAASQ,uBAAuBA,CAC9BC,UAAoD;EAEpD,IAAI,CAACA,UAAU,EAAE,OAAOzB,SAAS;EAEjC,MAAM0D,qBAAqB,GAAGjC,UAAU,CAACkC,IAAI,CAC3CC,SAAS,IAAIA,SAAS,CAACC,IAAI,CAACC,KAAK,KAAK,cAAc,CACrD;EACD,IAAI,CAACJ,qBAAqB,EAAE,OAAO1D,SAAS;EAE5C,IAAI,CAAC0D,qBAAqB,CAAC5D,SAAS,EAAE,OAAOE,SAAS;EAEtD,MAAM+D,cAAc,GAAGL,qBAAqB,CAAC5D,SAAS,CAAC6D,IAAI,CACzDK,QAAQ,IAAIA,QAAQ,CAACH,IAAI,CAACC,KAAK,KAAK,QAAQ,CAC7C;EACD,MAAMG,aAAa,GAAGP,qBAAqB,CAAC5D,SAAS,CAAC6D,IAAI,CACxDK,QAAQ,IAAIA,QAAQ,CAACH,IAAI,CAACC,KAAK,KAAK,OAAO,CAC5C;EAGD,OAAO;IACL9B,MAAM,EACJ+B,cAAc,IACdA,cAAc,CAACD,KAAK,IACpBC,cAAc,CAACD,KAAK,CAACI,IAAI,KAAK,UAAU,GACpCC,QAAQ,CAACJ,cAAc,CAACD,KAAK,CAACA,KAAK,CAAC,GACpC9D,SAAS;IACfiC,KAAK,EACHgC,aAAa,IACbA,aAAa,CAACH,KAAK,IACnBG,aAAa,CAACH,KAAK,CAACI,IAAI,KAAK,WAAW,GACnCD,aAAa,CAACH,KAAK,CAACA,KAAoB,GACzC9D;GACP;AACH;AAEA,SAASuB,UAAUA,CACjBP,IAAe,EACfoD,SAAgC;EAEhC,IAAI,CAACA,SAAS,EAAE,OAAOpD,IAAI;EAE3B,OAAO;IACLgB,MAAM,EAAEoC,SAAS,CAACpC,MAAM,KAAKhC,SAAS,GAAGoE,SAAS,CAACpC,MAAM,GAAGhB,IAAI,CAACgB,MAAM;IACvEC,KAAK,EAAEmC,SAAS,CAACnC,KAAK,IAAIjB,IAAI,CAACiB;GAChC;AACH;AAEA,SAASvB,yBAAyBA,CAChCJ,KAA2B;EAE3B,IAAI+D,YAAY,GAAuBrE,SAAS;EAChD,IAAIiC,KAAK,GAAevC,UAAU,CAAC4E,MAAM;EAEzC,KAAK,MAAMtD,IAAI,IAAIV,KAAK,CAACiE,MAAM,EAAE,EAAE;IACjC,IAAIvD,IAAI,CAACgB,MAAM,KAAKhC,SAAS,EAAE;MAC7BqE,YAAY,GACVA,YAAY,KAAKrE,SAAS,GACtBwE,IAAI,CAACC,GAAG,CAACJ,YAAY,EAAErD,IAAI,CAACgB,MAAM,CAAC,GACnChB,IAAI,CAACgB,MAAM;;IAEnB,IAAIhB,IAAI,CAACiB,KAAK,KAAKvC,UAAU,CAACgF,OAAO,EAAE;MACrCzC,KAAK,GAAGvC,UAAU,CAACgF,OAAO;;;EAM9B,OAAOL,YAAY,GACf;IACErC,MAAM,EAAEqC,YAAY;IACpBpC;GACD,GACDjC,SAAS;AACf;AAEA,SAASkC,OAAOA,CAAC5B,KAA2B,EAAEwB,IAAkB,EAAEd,IAAe;EAC/E,MAAM2D,iBAAiB,GAAGrE,KAAK,CAACsE,GAAG,CAAC9C,IAAI,CAAC;EACzC,IAAI6C,iBAAiB,EAAE;IACrBrE,KAAK,CAACwC,GAAG,CAAChB,IAAI,EAAEP,UAAU,CAACoD,iBAAiB,EAAE3D,IAAI,CAAC,CAAC;GACrD,MAAM;IACLV,KAAK,CAACwC,GAAG,CAAChB,IAAI,EAAEd,IAAI,CAAC;;AAEzB;AAEarB,OAAA,CAAAkF,WAAW,GAAG;EACzB3C,OAAO;EACPxB;CACD"},"metadata":{},"sourceType":"script","externalDependencies":[]}