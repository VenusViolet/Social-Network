{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DurationHistogram = void 0;\nclass DurationHistogram {\n  constructor(options) {\n    const initSize = (options === null || options === void 0 ? void 0 : options.initSize) || 74;\n    const buckets = options === null || options === void 0 ? void 0 : options.buckets;\n    const arrayInitSize = Math.max((buckets === null || buckets === void 0 ? void 0 : buckets.length) || 0, initSize);\n    this.buckets = Array(arrayInitSize).fill(0);\n    if (buckets) {\n      buckets.forEach((val, index) => this.buckets[index] = val);\n    }\n  }\n  toArray() {\n    let bufferedZeroes = 0;\n    const outputArray = [];\n    for (const value of this.buckets) {\n      if (value === 0) {\n        bufferedZeroes++;\n      } else {\n        if (bufferedZeroes === 1) {\n          outputArray.push(0);\n        } else if (bufferedZeroes !== 0) {\n          outputArray.push(-bufferedZeroes);\n        }\n        outputArray.push(value);\n        bufferedZeroes = 0;\n      }\n    }\n    return outputArray;\n  }\n  static durationToBucket(durationNs) {\n    const log = Math.log(durationNs / 1000.0);\n    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);\n    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket) ? 0 : unboundedBucket >= DurationHistogram.BUCKET_COUNT ? DurationHistogram.BUCKET_COUNT - 1 : unboundedBucket;\n  }\n  incrementDuration(durationNs) {\n    this.incrementBucket(DurationHistogram.durationToBucket(durationNs));\n    return this;\n  }\n  incrementBucket(bucket) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (bucket >= DurationHistogram.BUCKET_COUNT) {\n      throw Error('Bucket is out of bounds of the buckets array');\n    }\n    if (bucket >= this.buckets.length) {\n      const oldLength = this.buckets.length;\n      this.buckets.length = bucket + 1;\n      this.buckets.fill(0, oldLength);\n    }\n    this.buckets[bucket] += value;\n  }\n  combine(otherHistogram) {\n    for (let i = 0; i < otherHistogram.buckets.length; i++) {\n      this.incrementBucket(i, otherHistogram.buckets[i]);\n    }\n  }\n}\nexports.DurationHistogram = DurationHistogram;\nDurationHistogram.BUCKET_COUNT = 384;\nDurationHistogram.EXPONENT_LOG = Math.log(1.1);","map":{"version":3,"names":["DurationHistogram","constructor","options","initSize","buckets","arrayInitSize","Math","max","length","Array","fill","forEach","val","index","toArray","bufferedZeroes","outputArray","value","push","durationToBucket","durationNs","log","unboundedBucket","ceil","EXPONENT_LOG","Number","isNaN","BUCKET_COUNT","incrementDuration","incrementBucket","bucket","arguments","undefined","Error","oldLength","combine","otherHistogram","i","exports"],"sources":["/Users/venusrodin/node_modules/apollo-server-core/src/plugin/usageReporting/durationHistogram.ts"],"sourcesContent":["export interface DurationHistogramOptions {\n  initSize?: number;\n  buckets?: number[];\n}\nexport class DurationHistogram {\n  private readonly buckets: number[];\n  static readonly BUCKET_COUNT = 384;\n  static readonly EXPONENT_LOG = Math.log(1.1);\n\n  toArray(): number[] {\n    let bufferedZeroes = 0;\n    const outputArray: number[] = [];\n\n    for (const value of this.buckets) {\n      if (value === 0) {\n        bufferedZeroes++;\n      } else {\n        if (bufferedZeroes === 1) {\n          outputArray.push(0);\n        } else if (bufferedZeroes !== 0) {\n          outputArray.push(-bufferedZeroes);\n        }\n        outputArray.push(value);\n        bufferedZeroes = 0;\n      }\n    }\n    return outputArray;\n  }\n\n  static durationToBucket(durationNs: number): number {\n    const log = Math.log(durationNs / 1000.0);\n    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);\n\n    // Compare <= 0 to catch -0 and -infinity\n    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)\n      ? 0\n      : unboundedBucket >= DurationHistogram.BUCKET_COUNT\n      ? DurationHistogram.BUCKET_COUNT - 1\n      : unboundedBucket;\n  }\n\n  incrementDuration(durationNs: number): DurationHistogram {\n    this.incrementBucket(DurationHistogram.durationToBucket(durationNs));\n    return this;\n  }\n\n  incrementBucket(bucket: number, value = 1) {\n    if (bucket >= DurationHistogram.BUCKET_COUNT) {\n      // Since we don't have fixed size arrays I'd rather throw the error manually\n      throw Error('Bucket is out of bounds of the buckets array');\n    }\n\n    // Extend the array if we haven't gotten it long enough to handle the new bucket\n    if (bucket >= this.buckets.length) {\n      const oldLength = this.buckets.length;\n      this.buckets.length = bucket + 1;\n      this.buckets.fill(0, oldLength);\n    }\n\n    this.buckets[bucket] += value;\n  }\n\n  combine(otherHistogram: DurationHistogram) {\n    for (let i = 0; i < otherHistogram.buckets.length; i++) {\n      this.incrementBucket(i, otherHistogram.buckets[i]);\n    }\n  }\n\n  constructor(options?: DurationHistogramOptions) {\n    const initSize = options?.initSize || 74;\n    const buckets = options?.buckets;\n\n    const arrayInitSize = Math.max(buckets?.length || 0, initSize);\n\n    this.buckets = Array<number>(arrayInitSize).fill(0);\n\n    if (buckets) {\n      buckets.forEach((val, index) => (this.buckets[index] = val));\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}