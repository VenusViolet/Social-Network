{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addResolversToSchema = exports.buildSchemaFromSDL = exports.modulesFromSDL = void 0;\nconst graphql_1 = require(\"graphql\");\nconst validate_1 = require(\"graphql/validation/validate\");\nconst graphql_2 = require(\"../utilities/graphql\");\nconst GraphQLSchemaValidationError_1 = require(\"./GraphQLSchemaValidationError\");\nconst specifiedRules_1 = require(\"graphql/validation/specifiedRules\");\nconst flat_1 = __importDefault(require(\"core-js-pure/features/array/flat\"));\nconst validation_1 = require(\"graphql/validation\");\nconst mapValues_1 = require(\"../utilities/mapValues\");\nconst skippedSDLRules = [validation_1.KnownTypeNamesRule, validation_1.UniqueDirectivesPerLocationRule];\ntry {\n  const PossibleTypeExtensions = require(\"graphql/validation/rules/PossibleTypeExtensions\").PossibleTypeExtensions;\n  if (PossibleTypeExtensions) {\n    skippedSDLRules.push(PossibleTypeExtensions);\n  }\n} catch (e) {}\nconst sdlRules = specifiedRules_1.specifiedSDLRules.filter(rule => !skippedSDLRules.includes(rule));\nfunction modulesFromSDL(modulesOrSDL) {\n  if (Array.isArray(modulesOrSDL)) {\n    return modulesOrSDL.map(moduleOrSDL => {\n      if ((0, graphql_2.isNode)(moduleOrSDL) && (0, graphql_2.isDocumentNode)(moduleOrSDL)) {\n        return {\n          typeDefs: moduleOrSDL\n        };\n      } else {\n        return moduleOrSDL;\n      }\n    });\n  } else {\n    return [{\n      typeDefs: modulesOrSDL\n    }];\n  }\n}\nexports.modulesFromSDL = modulesFromSDL;\nfunction buildSchemaFromSDL(modulesOrSDL, schemaToExtend) {\n  const modules = modulesFromSDL(modulesOrSDL);\n  const documentAST = (0, graphql_1.concatAST)(modules.map(module => module.typeDefs));\n  const errors = (0, validate_1.validateSDL)(documentAST, schemaToExtend, sdlRules);\n  if (errors.length > 0) {\n    throw new GraphQLSchemaValidationError_1.GraphQLSchemaValidationError(errors);\n  }\n  const definitionsMap = Object.create(null);\n  const extensionsMap = Object.create(null);\n  const directiveDefinitions = [];\n  const schemaDefinitions = [];\n  const schemaExtensions = [];\n  const schemaDirectives = [];\n  for (const definition of documentAST.definitions) {\n    if ((0, graphql_1.isTypeDefinitionNode)(definition)) {\n      const typeName = definition.name.value;\n      if (definitionsMap[typeName]) {\n        definitionsMap[typeName].push(definition);\n      } else {\n        definitionsMap[typeName] = [definition];\n      }\n    } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {\n      const typeName = definition.name.value;\n      if (extensionsMap[typeName]) {\n        extensionsMap[typeName].push(definition);\n      } else {\n        extensionsMap[typeName] = [definition];\n      }\n    } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefinitions.push(definition);\n    } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n      schemaDefinitions.push(definition);\n      schemaDirectives.push(...(definition.directives ? definition.directives : []));\n    } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(definition);\n    }\n  }\n  let schema = schemaToExtend ? schemaToExtend : new graphql_1.GraphQLSchema({\n    query: undefined\n  });\n  const missingTypeDefinitions = [];\n  for (const [extendedTypeName, extensions] of Object.entries(extensionsMap)) {\n    if (!definitionsMap[extendedTypeName]) {\n      const extension = extensions[0];\n      const kind = extension.kind;\n      const definition = {\n        kind: extKindToDefKind[kind],\n        name: extension.name\n      };\n      missingTypeDefinitions.push(definition);\n    }\n  }\n  schema = (0, graphql_1.extendSchema)(schema, {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: [...(0, flat_1.default)(Object.values(definitionsMap)), ...missingTypeDefinitions, ...directiveDefinitions]\n  }, {\n    assumeValidSDL: true\n  });\n  schema = (0, graphql_1.extendSchema)(schema, {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: (0, flat_1.default)(Object.values(extensionsMap))\n  }, {\n    assumeValidSDL: true\n  });\n  let operationTypeMap;\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n    const operationTypes = (0, flat_1.default)([...schemaDefinitions, ...schemaExtensions].map(node => node.operationTypes).filter(isNotNullOrUndefined));\n    for (const {\n      operation,\n      type\n    } of operationTypes) {\n      operationTypeMap[operation] = type.name.value;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\"\n    };\n  }\n  schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign(Object.assign({}, schema.toConfig()), (0, mapValues_1.mapValues)(operationTypeMap, typeName => typeName ? schema.getType(typeName) : undefined)), {\n    astNode: {\n      kind: graphql_1.Kind.SCHEMA_DEFINITION,\n      directives: schemaDirectives,\n      operationTypes: []\n    }\n  }));\n  for (const module of modules) {\n    if (!module.resolvers) continue;\n    addResolversToSchema(schema, module.resolvers);\n  }\n  return schema;\n}\nexports.buildSchemaFromSDL = buildSchemaFromSDL;\nconst extKindToDefKind = {\n  [graphql_1.Kind.SCALAR_TYPE_EXTENSION]: graphql_1.Kind.SCALAR_TYPE_DEFINITION,\n  [graphql_1.Kind.OBJECT_TYPE_EXTENSION]: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  [graphql_1.Kind.INTERFACE_TYPE_EXTENSION]: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n  [graphql_1.Kind.UNION_TYPE_EXTENSION]: graphql_1.Kind.UNION_TYPE_DEFINITION,\n  [graphql_1.Kind.ENUM_TYPE_EXTENSION]: graphql_1.Kind.ENUM_TYPE_DEFINITION,\n  [graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION]: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION\n};\nfunction addResolversToSchema(schema, resolvers) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n    if ((0, graphql_1.isAbstractType)(type)) {\n      for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n        if (fieldName.startsWith(\"__\")) {\n          type[fieldName.substring(2)] = fieldConfig;\n        }\n      }\n    }\n    if ((0, graphql_1.isScalarType)(type)) {\n      for (const fn in fieldConfigs) {\n        type[fn] = fieldConfigs[fn];\n      }\n    }\n    if ((0, graphql_1.isEnumType)(type)) {\n      const values = type.getValues();\n      const newValues = {};\n      values.forEach(value => {\n        let newValue = fieldConfigs[value.name];\n        if (newValue === undefined) {\n          newValue = value.name;\n        }\n        newValues[value.name] = {\n          value: newValue,\n          deprecationReason: value.deprecationReason,\n          description: value.description,\n          astNode: value.astNode,\n          extensions: undefined\n        };\n      });\n      Object.assign(type, new graphql_1.GraphQLEnumType(Object.assign(Object.assign({}, type.toConfig()), {\n        values: newValues\n      })));\n    }\n    if (!(0, graphql_1.isObjectType)(type)) continue;\n    const fieldMap = type.getFields();\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        type[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        field.resolve = fieldConfig.resolve;\n      }\n    }\n  }\n}\nexports.addResolversToSchema = addResolversToSchema;\nfunction isNotNullOrUndefined(value) {\n  return value !== null && typeof value !== \"undefined\";\n}","map":{"version":3,"names":["graphql_1","require","validate_1","graphql_2","GraphQLSchemaValidationError_1","specifiedRules_1","flat_1","__importDefault","validation_1","mapValues_1","skippedSDLRules","KnownTypeNamesRule","UniqueDirectivesPerLocationRule","PossibleTypeExtensions","push","e","sdlRules","specifiedSDLRules","filter","rule","includes","modulesFromSDL","modulesOrSDL","Array","isArray","map","moduleOrSDL","isNode","isDocumentNode","typeDefs","exports","buildSchemaFromSDL","schemaToExtend","modules","documentAST","concatAST","module","errors","validateSDL","length","GraphQLSchemaValidationError","definitionsMap","Object","create","extensionsMap","directiveDefinitions","schemaDefinitions","schemaExtensions","schemaDirectives","definition","definitions","isTypeDefinitionNode","typeName","name","value","isTypeExtensionNode","kind","Kind","DIRECTIVE_DEFINITION","SCHEMA_DEFINITION","directives","SCHEMA_EXTENSION","schema","GraphQLSchema","query","undefined","missingTypeDefinitions","extendedTypeName","extensions","entries","extension","extKindToDefKind","extendSchema","DOCUMENT","default","values","assumeValidSDL","operationTypeMap","operationTypes","node","isNotNullOrUndefined","operation","type","mutation","subscription","assign","toConfig","mapValues","getType","astNode","resolvers","addResolversToSchema","SCALAR_TYPE_EXTENSION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_EXTENSION","UNION_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","ENUM_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","fieldConfigs","isAbstractType","fieldName","fieldConfig","startsWith","substring","isScalarType","fn","isEnumType","getValues","newValues","forEach","newValue","deprecationReason","description","GraphQLEnumType","isObjectType","fieldMap","getFields","field","resolve"],"sources":["/Users/venusrodin/node_modules/apollo-graphql/src/schema/buildSchemaFromSDL.ts"],"sourcesContent":["import {\n  concatAST,\n  DocumentNode,\n  extendSchema,\n  GraphQLSchema,\n  isObjectType,\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n  Kind,\n  TypeDefinitionNode,\n  TypeExtensionNode,\n  DirectiveDefinitionNode,\n  SchemaDefinitionNode,\n  SchemaExtensionNode,\n  OperationTypeNode,\n  GraphQLObjectType,\n  GraphQLEnumType,\n  isAbstractType,\n  isScalarType,\n  isEnumType,\n  GraphQLEnumValueConfig,\n  DirectiveNode,\n} from \"graphql\";\nimport { validateSDL } from \"graphql/validation/validate\";\nimport { isDocumentNode, isNode } from \"../utilities/graphql\";\nimport { GraphQLResolverMap } from \"./resolverMap\";\nimport { GraphQLSchemaValidationError } from \"./GraphQLSchemaValidationError\";\nimport { specifiedSDLRules } from \"graphql/validation/specifiedRules\";\n\n// TODO(Node.js 10): When we deprecate Node.js 10, remove this and switch\n// to using `Array.prototype.flat`.  When doing this, deleting the hand-rolled\n// types in `./packages/apollo-gateway/src/types/` that go with it.\nimport flat from \"core-js-pure/features/array/flat\";\n\nimport {\n  KnownTypeNamesRule,\n  UniqueDirectivesPerLocationRule,\n  ValidationRule,\n} from \"graphql/validation\";\nimport { mapValues } from \"../utilities/mapValues\";\n\nexport interface GraphQLSchemaModule {\n  typeDefs: DocumentNode;\n  resolvers?: GraphQLResolverMap<any>;\n}\n\nconst skippedSDLRules: ValidationRule[] = [\n  KnownTypeNamesRule,\n  UniqueDirectivesPerLocationRule,\n];\n\n// BREAKING VERSION: Remove this when graphql-js 15 is minimum version.\n// Currently, this PossibleTypeExtensions rule is experimental and thus not\n// exposed directly from the rules module above. This may change in the future!\n// Additionally, it does not exist in prior graphql versions. Thus this try/catch.\ntry {\n  const PossibleTypeExtensions: typeof import(\"graphql/validation/rules/PossibleTypeExtensions\").PossibleTypeExtensions =\n    require(\"graphql/validation/rules/PossibleTypeExtensions\").PossibleTypeExtensions;\n  if (PossibleTypeExtensions) {\n    skippedSDLRules.push(PossibleTypeExtensions);\n  }\n} catch (e) {\n  // No need to fail in this case.  Instead, if this validation rule is missing, we will assume its not used\n  // by the version of `graphql` that is available to us.\n}\n\nconst sdlRules = specifiedSDLRules.filter(\n  (rule) => !skippedSDLRules.includes(rule)\n);\n\nexport function modulesFromSDL(\n  modulesOrSDL: (GraphQLSchemaModule | DocumentNode)[] | DocumentNode\n): GraphQLSchemaModule[] {\n  if (Array.isArray(modulesOrSDL)) {\n    return modulesOrSDL.map((moduleOrSDL) => {\n      if (isNode(moduleOrSDL) && isDocumentNode(moduleOrSDL)) {\n        return { typeDefs: moduleOrSDL };\n      } else {\n        return moduleOrSDL;\n      }\n    });\n  } else {\n    return [{ typeDefs: modulesOrSDL }];\n  }\n}\n\nexport function buildSchemaFromSDL(\n  modulesOrSDL: (GraphQLSchemaModule | DocumentNode)[] | DocumentNode,\n  schemaToExtend?: GraphQLSchema\n): GraphQLSchema {\n  const modules = modulesFromSDL(modulesOrSDL);\n\n  const documentAST = concatAST(modules.map((module) => module.typeDefs));\n\n  const errors = validateSDL(documentAST, schemaToExtend, sdlRules);\n  if (errors.length > 0) {\n    throw new GraphQLSchemaValidationError(errors);\n  }\n\n  const definitionsMap: {\n    [name: string]: TypeDefinitionNode[];\n  } = Object.create(null);\n\n  const extensionsMap: {\n    [name: string]: TypeExtensionNode[];\n  } = Object.create(null);\n\n  const directiveDefinitions: DirectiveDefinitionNode[] = [];\n\n  const schemaDefinitions: SchemaDefinitionNode[] = [];\n  const schemaExtensions: SchemaExtensionNode[] = [];\n  const schemaDirectives: DirectiveNode[] = [];\n\n  for (const definition of documentAST.definitions) {\n    if (isTypeDefinitionNode(definition)) {\n      const typeName = definition.name.value;\n\n      if (definitionsMap[typeName]) {\n        definitionsMap[typeName].push(definition);\n      } else {\n        definitionsMap[typeName] = [definition];\n      }\n    } else if (isTypeExtensionNode(definition)) {\n      const typeName = definition.name.value;\n\n      if (extensionsMap[typeName]) {\n        extensionsMap[typeName].push(definition);\n      } else {\n        extensionsMap[typeName] = [definition];\n      }\n    } else if (definition.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefinitions.push(definition);\n    } else if (definition.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDefinitions.push(definition);\n      schemaDirectives.push(\n        ...(definition.directives ? definition.directives : [])\n      );\n    } else if (definition.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(definition);\n    }\n  }\n\n  let schema = schemaToExtend\n    ? schemaToExtend\n    : new GraphQLSchema({\n        query: undefined,\n      });\n\n  const missingTypeDefinitions: TypeDefinitionNode[] = [];\n\n  for (const [extendedTypeName, extensions] of Object.entries(extensionsMap)) {\n    if (!definitionsMap[extendedTypeName]) {\n      const extension = extensions[0];\n\n      const kind = extension.kind;\n      const definition = {\n        kind: extKindToDefKind[kind],\n        name: extension.name,\n      } as TypeDefinitionNode;\n\n      missingTypeDefinitions.push(definition);\n    }\n  }\n\n  schema = extendSchema(\n    schema,\n    {\n      kind: Kind.DOCUMENT,\n      definitions: [\n        ...flat(Object.values(definitionsMap)),\n        ...missingTypeDefinitions,\n        ...directiveDefinitions,\n      ],\n    },\n    {\n      assumeValidSDL: true,\n    }\n  );\n\n  schema = extendSchema(\n    schema,\n    {\n      kind: Kind.DOCUMENT,\n      definitions: flat(Object.values(extensionsMap)),\n    },\n    {\n      assumeValidSDL: true,\n    }\n  );\n\n  let operationTypeMap: { [operation in OperationTypeNode]?: string };\n\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n\n    const operationTypes = flat(\n      [...schemaDefinitions, ...schemaExtensions]\n        .map((node) => node.operationTypes)\n        .filter(isNotNullOrUndefined)\n    );\n\n    for (const { operation, type } of operationTypes) {\n      operationTypeMap[operation] = type.name.value;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\",\n    };\n  }\n\n  schema = new GraphQLSchema({\n    ...schema.toConfig(),\n    ...mapValues(operationTypeMap, (typeName) =>\n      typeName\n        ? (schema.getType(typeName) as GraphQLObjectType<any, any>)\n        : undefined\n    ),\n    astNode: {\n      kind: Kind.SCHEMA_DEFINITION,\n      directives: schemaDirectives,\n      operationTypes: [], // satisfies typescript, will be ignored\n    },\n  });\n\n  for (const module of modules) {\n    if (!module.resolvers) continue;\n    addResolversToSchema(schema, module.resolvers);\n  }\n\n  return schema;\n}\n\nconst extKindToDefKind = {\n  [Kind.SCALAR_TYPE_EXTENSION]: Kind.SCALAR_TYPE_DEFINITION,\n  [Kind.OBJECT_TYPE_EXTENSION]: Kind.OBJECT_TYPE_DEFINITION,\n  [Kind.INTERFACE_TYPE_EXTENSION]: Kind.INTERFACE_TYPE_DEFINITION,\n  [Kind.UNION_TYPE_EXTENSION]: Kind.UNION_TYPE_DEFINITION,\n  [Kind.ENUM_TYPE_EXTENSION]: Kind.ENUM_TYPE_DEFINITION,\n  [Kind.INPUT_OBJECT_TYPE_EXTENSION]: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n};\n\nexport function addResolversToSchema(\n  schema: GraphQLSchema,\n  resolvers: GraphQLResolverMap<any>\n) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n\n    if (isAbstractType(type)) {\n      for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n        if (fieldName.startsWith(\"__\")) {\n          (type as any)[fieldName.substring(2)] = fieldConfig;\n        }\n      }\n    }\n\n    if (isScalarType(type)) {\n      for (const fn in fieldConfigs) {\n        (type as any)[fn] = (fieldConfigs as any)[fn];\n      }\n    }\n\n    if (isEnumType(type)) {\n      const values = type.getValues();\n      const newValues: { [key: string]: GraphQLEnumValueConfig } = {};\n      values.forEach((value) => {\n        let newValue = (fieldConfigs as any)[value.name];\n        if (newValue === undefined) {\n          newValue = value.name;\n        }\n\n        newValues[value.name] = {\n          value: newValue,\n          deprecationReason: value.deprecationReason,\n          description: value.description,\n          astNode: value.astNode,\n          extensions: undefined,\n        };\n      });\n\n      // In place updating hack to get around pulling in the full\n      // schema walking and immutable updating machinery from graphql-tools\n      Object.assign(\n        type,\n        new GraphQLEnumType({\n          ...type.toConfig(),\n          values: newValues,\n        })\n      );\n    }\n\n    if (!isObjectType(type)) continue;\n\n    const fieldMap = type.getFields();\n\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        (type as any)[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        field.resolve = fieldConfig.resolve;\n      }\n    }\n  }\n}\n\nfunction isNotNullOrUndefined<T>(value: T | null | undefined): value is T {\n  return value !== null && typeof value !== \"undefined\";\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}