{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.signatureCacheKey = exports.createSignatureCache = void 0;\nconst lru_cache_1 = __importDefault(require(\"lru-cache\"));\nfunction createSignatureCache(_ref) {\n  let {\n    logger\n  } = _ref;\n  let lastSignatureCacheWarn;\n  let lastSignatureCacheDisposals = 0;\n  return new lru_cache_1.default({\n    length(obj) {\n      return Buffer.byteLength(JSON.stringify(obj), 'utf8');\n    },\n    max: Math.pow(2, 20) * 3,\n    dispose() {\n      lastSignatureCacheDisposals++;\n      if (!lastSignatureCacheWarn || new Date().getTime() - lastSignatureCacheWarn.getTime() > 60000) {\n        lastSignatureCacheWarn = new Date();\n        logger.warn(['This server is processing a high number of unique operations.  ', `A total of ${lastSignatureCacheDisposals} records have been `, 'ejected from the ApolloServerPluginUsageReporting signature cache in the past ', 'interval.  If you see this warning frequently, please open an ', 'issue on the Apollo Server repository.'].join(''));\n        lastSignatureCacheDisposals = 0;\n      }\n    }\n  });\n}\nexports.createSignatureCache = createSignatureCache;\nfunction signatureCacheKey(queryHash, operationName) {\n  return `${queryHash}${operationName && ':' + operationName}`;\n}\nexports.signatureCacheKey = signatureCacheKey;","map":{"version":3,"names":["lru_cache_1","__importDefault","require","createSignatureCache","_ref","logger","lastSignatureCacheWarn","lastSignatureCacheDisposals","default","length","obj","Buffer","byteLength","JSON","stringify","max","Math","pow","dispose","Date","getTime","warn","join","exports","signatureCacheKey","queryHash","operationName"],"sources":["/Users/venusrodin/node_modules/apollo-server-core/src/plugin/usageReporting/signatureCache.ts"],"sourcesContent":["import LRUCache from 'lru-cache';\nimport { Logger } from 'apollo-server-types';\n\nexport function createSignatureCache({\n  logger,\n}: {\n  logger: Logger;\n}): LRUCache<string, string> {\n  let lastSignatureCacheWarn: Date;\n  let lastSignatureCacheDisposals: number = 0;\n  return new LRUCache<string, string>({\n    // Calculate the length of cache objects by the JSON.stringify byteLength.\n    length(obj) {\n      return Buffer.byteLength(JSON.stringify(obj), 'utf8');\n    },\n    // 3MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing these strings internally. Though this should be enough to\n    // store a fair amount of operation signatures (~10000?), depending on their\n    // overall complexity. A future version of this might expose some\n    // configuration option to grow the cache, but ideally, we could do that\n    // dynamically based on the resources available to the server, and not add\n    // more configuration surface area. Hopefully the warning message will allow\n    // us to evaluate the need with more validated input from those that receive\n    // it.\n    max: Math.pow(2, 20) * 3,\n    dispose() {\n      // Count the number of disposals between warning messages.\n      lastSignatureCacheDisposals++;\n\n      // Only show a message warning about the high turnover every 60 seconds.\n      if (\n        !lastSignatureCacheWarn ||\n        new Date().getTime() - lastSignatureCacheWarn.getTime() > 60000\n      ) {\n        // Log the time that we last displayed the message.\n        lastSignatureCacheWarn = new Date();\n        logger.warn(\n          [\n            'This server is processing a high number of unique operations.  ',\n            `A total of ${lastSignatureCacheDisposals} records have been `,\n            'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',\n            'interval.  If you see this warning frequently, please open an ',\n            'issue on the Apollo Server repository.',\n          ].join(''),\n        );\n\n        // Reset the disposal counter for the next message interval.\n        lastSignatureCacheDisposals = 0;\n      }\n    },\n  });\n}\n\nexport function signatureCacheKey(queryHash: string, operationName: string) {\n  return `${queryHash}${operationName && ':' + operationName}`;\n}\n"],"mappings":";;;;;;;;;;;AAAA,MAAAA,WAAA,GAAAC,eAAA,CAAAC,OAAA;AAGA,SAAgBC,oBAAoBA,CAAAC,IAAA,EAInC;EAAA,IAJoC;IACnCC;EAAM,CAGP,GAAAD,IAAA;EACC,IAAIE,sBAA4B;EAChC,IAAIC,2BAA2B,GAAW,CAAC;EAC3C,OAAO,IAAIP,WAAA,CAAAQ,OAAQ,CAAiB;IAElCC,MAAMA,CAACC,GAAG;MACR,OAAOC,MAAM,CAACC,UAAU,CAACC,IAAI,CAACC,SAAS,CAACJ,GAAG,CAAC,EAAE,MAAM,CAAC;IACvD,CAAC;IAUDK,GAAG,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;IACxBC,OAAOA,CAAA;MAELX,2BAA2B,EAAE;MAG7B,IACE,CAACD,sBAAsB,IACvB,IAAIa,IAAI,EAAE,CAACC,OAAO,EAAE,GAAGd,sBAAsB,CAACc,OAAO,EAAE,GAAG,KAAK,EAC/D;QAEAd,sBAAsB,GAAG,IAAIa,IAAI,EAAE;QACnCd,MAAM,CAACgB,IAAI,CACT,CACE,iEAAiE,EACjE,cAAcd,2BAA2B,qBAAqB,EAC9D,gFAAgF,EAChF,gEAAgE,EAChE,wCAAwC,CACzC,CAACe,IAAI,CAAC,EAAE,CAAC,CACX;QAGDf,2BAA2B,GAAG,CAAC;;IAEnC;GACD,CAAC;AACJ;AAhDAgB,OAAA,CAAApB,oBAAA,GAAAA,oBAAA;AAkDA,SAAgBqB,iBAAiBA,CAACC,SAAiB,EAAEC,aAAqB;EACxE,OAAO,GAAGD,SAAS,GAAGC,aAAa,IAAI,GAAG,GAAGA,aAAa,EAAE;AAC9D;AAFAH,OAAA,CAAAC,iBAAA,GAAAA,iBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}