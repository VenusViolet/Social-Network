{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _1 = require(\".\");\nvar graphql_1 = require(\"graphql\");\nvar transforms_1 = require(\"../transforms/transforms\");\nvar _2 = require(\".\");\nvar ConvertEnumValues_1 = require(\"../transforms/ConvertEnumValues\");\nfunction addResolveFunctionsToSchema(options, legacyInputResolvers, legacyInputValidationOptions) {\n  if (options instanceof graphql_1.GraphQLSchema) {\n    console.warn('The addResolveFunctionsToSchema function takes named options now; see IAddResolveFunctionsToSchemaOptions');\n    options = {\n      schema: options,\n      resolvers: legacyInputResolvers,\n      resolverValidationOptions: legacyInputValidationOptions\n    };\n  }\n  var schema = options.schema,\n    inputResolvers = options.resolvers,\n    _a = options.resolverValidationOptions,\n    resolverValidationOptions = _a === void 0 ? {} : _a,\n    _b = options.inheritResolversFromInterfaces,\n    inheritResolversFromInterfaces = _b === void 0 ? false : _b;\n  var _c = resolverValidationOptions.allowResolversNotInSchema,\n    allowResolversNotInSchema = _c === void 0 ? false : _c,\n    requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\n  var resolvers = inheritResolversFromInterfaces ? _2.extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;\n  // Used to map the external value of an enum to its internal value, when\n  // that internal value is provided by a resolver.\n  var enumValueMap = Object.create(null);\n  Object.keys(resolvers).forEach(function (typeName) {\n    var resolverValue = resolvers[typeName];\n    var resolverType = typeof resolverValue;\n    if (resolverType !== 'object' && resolverType !== 'function') {\n      throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value \" + \"must be of type object or function.\");\n    }\n    var type = schema.getType(typeName);\n    if (!type && typeName !== '__schema') {\n      if (allowResolversNotInSchema) {\n        return;\n      }\n      throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\n    }\n    Object.keys(resolverValue).forEach(function (fieldName) {\n      if (fieldName.startsWith('__')) {\n        // this is for isTypeOf and resolveType and all the other stuff.\n        type[fieldName.substring(2)] = resolverValue[fieldName];\n        return;\n      }\n      if (type instanceof graphql_1.GraphQLScalarType) {\n        type[fieldName] = resolverValue[fieldName];\n        return;\n      }\n      if (type instanceof graphql_1.GraphQLEnumType) {\n        if (!type.getValue(fieldName)) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n          throw new _1.SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\n        }\n        // We've encountered an enum resolver that is being used to provide an\n        // internal enum value.\n        // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n        //\n        // We're storing a map of the current enums external facing value to\n        // its resolver provided internal value. This map is used to transform\n        // the current schema to a new schema that includes enums with the new\n        // internal value.\n        enumValueMap[type.name] = enumValueMap[type.name] || {};\n        enumValueMap[type.name][fieldName] = resolverValue[fieldName];\n        return;\n      }\n      // object type\n      var fields = getFieldsForType(type);\n      if (!fields) {\n        if (allowResolversNotInSchema) {\n          return;\n        }\n        throw new _1.SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\n      }\n      if (!fields[fieldName]) {\n        if (allowResolversNotInSchema) {\n          return;\n        }\n        throw new _1.SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\n      }\n      var field = fields[fieldName];\n      var fieldResolve = resolverValue[fieldName];\n      if (typeof fieldResolve === 'function') {\n        // for convenience. Allows shorter syntax in resolver definition file\n        setFieldProperties(field, {\n          resolve: fieldResolve\n        });\n      } else {\n        if (typeof fieldResolve !== 'object') {\n          throw new _1.SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\n        }\n        setFieldProperties(field, fieldResolve);\n      }\n    });\n  });\n  _2.checkForResolveTypeResolver(schema, requireResolversForResolveType);\n  // If there are any enum resolver functions (that are used to return\n  // internal enum values), create a new schema that includes enums with the\n  // new internal facing values.\n  var updatedSchema = transforms_1.applySchemaTransforms(schema, [new ConvertEnumValues_1.default(enumValueMap)]);\n  return updatedSchema;\n}\nfunction getFieldsForType(type) {\n  if (type instanceof graphql_1.GraphQLObjectType || type instanceof graphql_1.GraphQLInterfaceType) {\n    return type.getFields();\n  } else {\n    return undefined;\n  }\n}\nfunction setFieldProperties(field, propertiesObj) {\n  Object.keys(propertiesObj).forEach(function (propertyName) {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n}\nexports.default = addResolveFunctionsToSchema;","map":{"version":3,"names":["_1","require","graphql_1","transforms_1","_2","ConvertEnumValues_1","addResolveFunctionsToSchema","options","legacyInputResolvers","legacyInputValidationOptions","GraphQLSchema","console","warn","schema","resolvers","resolverValidationOptions","inputResolvers","_a","_b","inheritResolversFromInterfaces","_c","allowResolversNotInSchema","requireResolversForResolveType","extendResolversFromInterfaces","enumValueMap","Object","create","keys","forEach","typeName","resolverValue","resolverType","SchemaError","type","getType","fieldName","startsWith","substring","GraphQLScalarType","GraphQLEnumType","getValue","name","fields","getFieldsForType","field","fieldResolve","setFieldProperties","resolve","checkForResolveTypeResolver","updatedSchema","applySchemaTransforms","default","GraphQLObjectType","GraphQLInterfaceType","getFields","undefined","propertiesObj","propertyName","exports"],"sources":["../../src/generate/addResolveFunctionsToSchema.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}