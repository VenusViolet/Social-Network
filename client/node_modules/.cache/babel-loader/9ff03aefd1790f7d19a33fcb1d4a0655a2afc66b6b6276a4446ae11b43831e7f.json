{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dispatcher = void 0;\nclass Dispatcher {\n  constructor(targets) {\n    this.targets = targets;\n  }\n  callTargets(targets, methodName) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    return targets.map(target => {\n      const method = target[methodName];\n      if (method && typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n  invokeHookAsync(methodName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield Promise.all(this.callTargets(this.targets, methodName, ...args));\n    });\n  }\n  invokeHookSync(methodName) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return this.callTargets(this.targets, methodName, ...args);\n  }\n  reverseInvokeHookSync(methodName) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    return this.callTargets(this.targets.reverse(), methodName, ...args);\n  }\n  invokeHooksUntilNonNull(methodName) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const target of this.targets) {\n        const method = target[methodName];\n        if (!(method && typeof method === 'function')) {\n          continue;\n        }\n        const value = yield method.apply(target, args);\n        if (value !== null) {\n          return value;\n        }\n      }\n      return null;\n    });\n  }\n  invokeDidStartHook(methodName) {\n    const didEndHooks = [];\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (method && typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n    return function () {\n      didEndHooks.reverse();\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...arguments);\n      }\n    };\n  }\n}\nexports.Dispatcher = Dispatcher;","map":{"version":3,"names":["Dispatcher","constructor","targets","callTargets","methodName","_len","arguments","length","args","Array","_key","map","target","method","apply","invokeHookAsync","_len2","_key2","Promise","all","invokeHookSync","_len3","_key3","reverseInvokeHookSync","_len4","_key4","reverse","invokeHooksUntilNonNull","_len5","_key5","value","invokeDidStartHook","didEndHooks","_len6","_key6","didEndHook","push","exports"],"sources":["/Users/venusrodin/node_modules/apollo-server-core/src/utils/dispatcher.ts"],"sourcesContent":["import { AnyFunction, AnyFunctionMap } from \"apollo-server-types\";\n\ntype Args<F> = F extends (...args: infer A) => any ? A : never;\ntype AsFunction<F> = F extends AnyFunction ? F : never;\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n\ntype DidEndHook<TArgs extends any[]> = (...args: TArgs) => void;\n\nexport class Dispatcher<T extends AnyFunctionMap> {\n  constructor(protected targets: T[]) {}\n\n  private callTargets<TMethodName extends keyof T>(\n    targets: T[],\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): ReturnType<AsFunction<T[TMethodName]>>[] {\n    return targets.map(target => {\n      const method = target[methodName];\n      if (method && typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n\n  public async invokeHookAsync<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<ReturnType<AsFunction<T[TMethodName]>>[]> {\n    return await Promise.all(\n      this.callTargets(this.targets, methodName, ...args));\n  }\n\n  public invokeHookSync<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): ReturnType<AsFunction<T[TMethodName]>>[] {\n    return this.callTargets(this.targets, methodName, ...args);\n  }\n\n  public reverseInvokeHookSync<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): ReturnType<AsFunction<T[TMethodName]>>[] {\n    return this.callTargets(this.targets.reverse(), methodName, ...args);\n  }\n\n  public async invokeHooksUntilNonNull<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<UnwrapPromise<ReturnType<AsFunction<T[TMethodName]>>> | null> {\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (!(method && typeof method === 'function')) {\n        continue;\n      }\n      const value = await method.apply(target, args);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n\n  public invokeDidStartHook<\n    TMethodName extends keyof T,\n    TEndHookArgs extends Args<ReturnType<AsFunction<T[TMethodName]>>>\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): DidEndHook<TEndHookArgs> {\n    const didEndHooks: DidEndHook<TEndHookArgs>[] = [];\n\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (method && typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n\n    return (...args: TEndHookArgs) => {\n      didEndHooks.reverse();\n\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...args);\n      }\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}