{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.plugin = void 0;\nconst graphql_1 = require(\"graphql\");\nconst {\n  name: PACKAGE_NAME\n} = require(\"../package.json\");\nexports.plugin = function () {\n  let _futureOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return () => ({\n    requestDidStart() {\n      const startWallTime = new Date();\n      let endWallTime;\n      const startHrTime = process.hrtime();\n      let duration;\n      const resolverCalls = [];\n      return {\n        executionDidStart: () => ({\n          executionDidEnd: () => {\n            duration = process.hrtime(startHrTime);\n            endWallTime = new Date();\n          },\n          willResolveField(_ref) {\n            let {\n              info\n            } = _ref;\n            const resolverCall = {\n              path: info.path,\n              fieldName: info.fieldName,\n              parentType: info.parentType,\n              returnType: info.returnType,\n              startOffset: process.hrtime(startHrTime)\n            };\n            resolverCalls.push(resolverCall);\n            return () => {\n              resolverCall.endOffset = process.hrtime(startHrTime);\n            };\n          }\n        }),\n        willSendResponse(_ref2) {\n          let {\n            response\n          } = _ref2;\n          if (typeof endWallTime === 'undefined' || typeof duration === 'undefined') {\n            return;\n          }\n          const extensions = response.extensions || (response.extensions = Object.create(null));\n          if (typeof extensions.tracing !== 'undefined') {\n            throw new Error(PACKAGE_NAME + \": Could not add `tracing` to \" + \"`extensions` since `tracing` was unexpectedly already present.\");\n          }\n          extensions.tracing = {\n            version: 1,\n            startTime: startWallTime.toISOString(),\n            endTime: endWallTime.toISOString(),\n            duration: durationHrTimeToNanos(duration),\n            execution: {\n              resolvers: resolverCalls.map(resolverCall => {\n                const startOffset = durationHrTimeToNanos(resolverCall.startOffset);\n                const duration = resolverCall.endOffset ? durationHrTimeToNanos(resolverCall.endOffset) - startOffset : 0;\n                return {\n                  path: [...graphql_1.responsePathAsArray(resolverCall.path)],\n                  parentType: resolverCall.parentType.toString(),\n                  fieldName: resolverCall.fieldName,\n                  returnType: resolverCall.returnType.toString(),\n                  startOffset,\n                  duration\n                };\n              })\n            }\n          };\n        }\n      };\n    }\n  });\n};\nfunction durationHrTimeToNanos(hrtime) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}","map":{"version":3,"names":["graphql_1","require","name","PACKAGE_NAME","exports","plugin","_futureOptions","arguments","length","undefined","requestDidStart","startWallTime","Date","endWallTime","startHrTime","process","hrtime","duration","resolverCalls","executionDidStart","executionDidEnd","willResolveField","_ref","info","resolverCall","path","fieldName","parentType","returnType","startOffset","push","endOffset","willSendResponse","_ref2","response","extensions","Object","create","tracing","Error","version","startTime","toISOString","endTime","durationHrTimeToNanos","execution","resolvers","map","responsePathAsArray","toString"],"sources":["/Users/venusrodin/node_modules/apollo-tracing/src/index.ts"],"sourcesContent":["import {\n  ResponsePath,\n  responsePathAsArray,\n  GraphQLType,\n} from 'graphql';\nimport { ApolloServerPlugin } from \"apollo-server-plugin-base\";\n\nconst { name: PACKAGE_NAME } = require(\"../package.json\");\n\nexport interface TracingFormat {\n  version: 1;\n  startTime: string;\n  endTime: string;\n  duration: number;\n  execution: {\n    resolvers: {\n      path: (string | number)[];\n      parentType: string;\n      fieldName: string;\n      returnType: string;\n      startOffset: number;\n      duration: number;\n    }[];\n  };\n}\n\ninterface ResolverCall {\n  path: ResponsePath;\n  fieldName: string;\n  parentType: GraphQLType;\n  returnType: GraphQLType;\n  startOffset: HighResolutionTime;\n  endOffset?: HighResolutionTime;\n}\n\nexport const plugin = (_futureOptions = {}) => (): ApolloServerPlugin => ({\n  requestDidStart() {\n    const startWallTime: Date = new Date();\n    let endWallTime: Date | undefined;\n    const startHrTime: HighResolutionTime = process.hrtime();\n    let duration: HighResolutionTime | undefined;\n    const resolverCalls: ResolverCall[] = [];\n\n\n    return {\n      executionDidStart: () => ({\n        // It's a little odd that we record the end time after execution rather\n        // than at the end of the whole request, but because we need to include\n        // our formatted trace in the request itself, we have to record it\n        // before the request is over!\n\n        // Historically speaking: It's WAS odd that we don't do traces for parse\n        // or validation errors. Reason being: at the time that this was written\n        // (now a plugin but originally an extension)). That was the case\n        // because runQuery DIDN'T (again, at the time, when it was an\n        // extension) support that since format() was only invoked after\n        // execution.\n        executionDidEnd: () => {\n          duration = process.hrtime(startHrTime);\n          endWallTime = new Date();\n        },\n\n        willResolveField({ info }) {\n          const resolverCall: ResolverCall = {\n            path: info.path,\n            fieldName: info.fieldName,\n            parentType: info.parentType,\n            returnType: info.returnType,\n            startOffset: process.hrtime(startHrTime),\n          };\n\n          resolverCalls.push(resolverCall);\n\n          return () => {\n            resolverCall.endOffset = process.hrtime(startHrTime);\n          };\n        },\n      }),\n\n      willSendResponse({ response }) {\n        // In the event that we are called prior to the initialization of\n        // critical date metrics, we'll return undefined to signal that the\n        // extension did not format properly. Any undefined extension\n        // results are simply purged by the graphql-extensions module.\n        if (\n          typeof endWallTime === 'undefined' ||\n          typeof duration === 'undefined'\n        ) {\n          return;\n        }\n\n        const extensions =\n          response.extensions || (response.extensions = Object.create(null));\n\n        // Be defensive and make sure nothing else (other plugin, etc.) has\n        // already used the `tracing` property on `extensions`.\n        if (typeof extensions.tracing !== 'undefined') {\n          throw new Error(PACKAGE_NAME + \": Could not add `tracing` to \" +\n            \"`extensions` since `tracing` was unexpectedly already present.\");\n        }\n\n        // Set the extensions.\n        extensions.tracing = {\n          version: 1,\n          startTime: startWallTime.toISOString(),\n          endTime: endWallTime.toISOString(),\n          duration: durationHrTimeToNanos(duration),\n          execution: {\n            resolvers: resolverCalls.map(resolverCall => {\n              const startOffset = durationHrTimeToNanos(\n                resolverCall.startOffset,\n              );\n              const duration = resolverCall.endOffset\n                ? durationHrTimeToNanos(resolverCall.endOffset) - startOffset\n                : 0;\n              return {\n                path: [...responsePathAsArray(resolverCall.path)],\n                parentType: resolverCall.parentType.toString(),\n                fieldName: resolverCall.fieldName,\n                returnType: resolverCall.returnType.toString(),\n                startOffset,\n                duration,\n              };\n            }),\n          },\n        };\n      },\n    };\n  },\n})\n\ntype HighResolutionTime = [number, number];\n\n// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.\n//\n// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE\n// FROM process.hrtime() WITH NO ARGUMENTS.\n//\n// The entire point of the hrtime data structure is that the JavaScript Number\n// type can't represent all int64 values without loss of precision:\n// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function\n// on a duration that represents a value less than 104 days is fine. Calling\n// this function on an absolute time (which is generally roughly time since\n// system boot) is not a good idea.\nfunction durationHrTimeToNanos(hrtime: HighResolutionTime) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}