{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = void 0;\nconst durationHistogram_1 = require(\"./durationHistogram\");\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\nclass SizeEstimator {\n  constructor() {\n    this.bytes = 0;\n  }\n}\nexports.SizeEstimator = SizeEstimator;\nclass OurReport {\n  constructor(header) {\n    this.header = header;\n    this.tracesPerQuery = Object.create(null);\n    this.endTime = null;\n    this.sizeEstimator = new SizeEstimator();\n  }\n  addTrace(_ref) {\n    let {\n      statsReportKey,\n      trace,\n      asTrace,\n      includeTracesContributingToStats\n    } = _ref;\n    const tracesAndStats = this.getTracesAndStats(statsReportKey);\n    if (asTrace) {\n      const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n      if (includeTracesContributingToStats) {\n        const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n  getTracesAndStats(statsReportKey) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n    return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats();\n  }\n}\nexports.OurReport = OurReport;\nclass OurTracesAndStats {\n  constructor() {\n    this.trace = [];\n    this.statsWithContext = new StatsByContext();\n    this.internalTracesContributingToStats = [];\n  }\n}\nclass StatsByContext {\n  constructor() {\n    this.map = Object.create(null);\n  }\n  toArray() {\n    return Object.values(this.map);\n  }\n  addTrace(trace, sizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);\n  }\n  getContextualizedStats(trace, sizeEstimator) {\n    const statsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n      clientReferenceId: trace.clientReferenceId\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion) + estimatedBytesForString(trace.clientReferenceId);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\nclass OurContextualizedStats {\n  constructor(context) {\n    this.context = context;\n    this.queryLatencyStats = new OurQueryLatencyStats();\n    this.perTypeStat = Object.create(null);\n  }\n  addTrace(trace, sizeEstimator) {\n    var _a;\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n    if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {\n      switch (trace.cachePolicy.scope) {\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n      }\n    }\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n    let hasError = false;\n    const traceNodeStats = (node, path) => {\n      var _a, _b, _c, _d, _e;\n      if ((_a = node.error) === null || _a === void 0 ? void 0 : _a.length) {\n        hasError = true;\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach(subPath => {\n          currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);\n        });\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n      const fieldName = node.originalFieldName || node.responseName;\n      if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {\n        const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n        const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);\n        fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n        fieldStat.count++;\n        fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;\n        fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime);\n      }\n      return false;\n    };\n    iterateOverTrace_1.iterateOverTrace(trace, traceNodeStats, true);\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n  getTypeStat(parentType, sizeEstimator) {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\nexports.OurContextualizedStats = OurContextualizedStats;\nclass OurQueryLatencyStats {\n  constructor() {\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n    this.requestCount = 0;\n    this.cacheHits = 0;\n    this.persistedQueryHits = 0;\n    this.persistedQueryMisses = 0;\n    this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();\n    this.rootErrorStats = new OurPathErrorStats();\n    this.requestsWithErrorsCount = 0;\n    this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.registeredOperationCount = 0;\n    this.forbiddenOperationCount = 0;\n  }\n}\nclass OurPathErrorStats {\n  constructor() {\n    this.children = Object.create(null);\n    this.errorsCount = 0;\n    this.requestsWithErrorsCount = 0;\n  }\n  getChild(subPath, sizeEstimator) {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\nclass OurTypeStat {\n  constructor() {\n    this.perFieldStat = Object.create(null);\n  }\n  getFieldStat(fieldName, returnType, sizeEstimator) {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n}\nclass OurFieldStat {\n  constructor(returnType) {\n    this.returnType = returnType;\n    this.errorsCount = 0;\n    this.count = 0;\n    this.requestsWithErrorsCount = 0;\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n  }\n}\nfunction estimatedBytesForString(s) {\n  return 2 + Buffer.byteLength(s);\n}","map":{"version":3,"names":["durationHistogram_1","require","apollo_reporting_protobuf_1","iterateOverTrace_1","SizeEstimator","constructor","bytes","exports","OurReport","header","tracesPerQuery","Object","create","endTime","sizeEstimator","addTrace","_ref","statsReportKey","trace","asTrace","includeTracesContributingToStats","tracesAndStats","getTracesAndStats","encodedTrace","Trace","encode","finish","push","length","statsWithContext","internalTracesContributingToStats","existing","estimatedBytesForString","OurTracesAndStats","StatsByContext","map","toArray","values","getContextualizedStats","statsContext","clientName","clientVersion","clientReferenceId","statsContextKey","JSON","stringify","contextualizedStats","OurContextualizedStats","context","queryLatencyStats","OurQueryLatencyStats","perTypeStat","requestCount","fullQueryCacheHit","cacheLatencyCount","incrementDuration","durationNs","cacheHits","latencyCount","_a","cachePolicy","maxAgeNs","scope","CachePolicy","Scope","PRIVATE","privateCacheTtlCount","PUBLIC","publicCacheTtlCount","persistedQueryHit","persistedQueryHits","persistedQueryRegister","persistedQueryMisses","forbiddenOperation","forbiddenOperationCount","registeredOperation","registeredOperationCount","hasError","traceNodeStats","node","path","error","currPathErrorStats","rootErrorStats","forEach","subPath","getChild","requestsWithErrorsCount","errorsCount","fieldName","originalFieldName","responseName","parentType","type","startTime","typeStat","getTypeStat","fieldStat","getFieldStat","_c","_b","count","_e","_d","iterateOverTrace","OurTypeStat","DurationHistogram","OurPathErrorStats","children","child","perFieldStat","returnType","OurFieldStat","s","Buffer","byteLength"],"sources":["/Users/venusrodin/node_modules/apollo-server-core/src/plugin/usageReporting/stats.ts"],"sourcesContent":["import { DurationHistogram } from './durationHistogram';\nimport {\n  IFieldStat,\n  IPathErrorStats,\n  IQueryLatencyStats,\n  IStatsContext,\n  Trace,\n  ITypeStat,\n  IContextualizedStats,\n  ReportHeader,\n  google,\n  ITracesAndStats,\n  IReport,\n} from 'apollo-reporting-protobuf';\nimport { iterateOverTrace, ResponseNamePath } from './iterateOverTrace';\n\n// protobuf.js exports both a class and an interface (starting with I) for each\n// message type. The class is what it produces when it decodes the message; the\n// interface is what is accepted as input. We build up our messages using custom\n// types implementing the interfaces, so that we can take advantage of the\n// js_use_toArray option we added to our protobuf.js fork which allows us to use\n// classes like DurationHistogram to generate repeated fields. We end up\n// re-creating most of the report structure as custom classes (starting with\n// \"Our\"). TypeScript validates that we've properly listed all of the message\n// fields with the appropriate types (we use `Required` to ensure we implement\n// all message fields). Using our own classes has other advantages, like being\n// able to specify that nested messages are instances of the same class rather\n// than the interface type and thus that they have non-null fields (because the\n// interface type allows all fields to be optional, even though the protobuf\n// format doesn't differentiate between missing and falsey).\n\nexport class SizeEstimator {\n  bytes = 0;\n}\nexport class OurReport implements Required<IReport> {\n  constructor(readonly header: ReportHeader) {}\n  readonly tracesPerQuery: Record<string, OurTracesAndStats> = Object.create(\n    null,\n  );\n  endTime: google.protobuf.ITimestamp | null = null;\n\n  // A rough estimate of the number of bytes currently in the report. We start\n  // at zero and don't count `header` and `endTime`, which have the same size\n  // for every report. This really is a rough estimate, so we don't stress too\n  // much about counting bytes for the tags and string/message lengths, etc:\n  // we mostly just count the lengths of strings plus some estimates for the\n  // messages with a bunch of numbers in them.\n  //\n  // We store this in a class so we can pass it down as a reference to other\n  // methods which increment it.\n  readonly sizeEstimator = new SizeEstimator();\n\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    includeTracesContributingToStats,\n  }: {\n    statsReportKey: string;\n    trace: Trace;\n    asTrace: boolean;\n    includeTracesContributingToStats: boolean;\n  }) {\n    const tracesAndStats = this.getTracesAndStats(statsReportKey);\n    if (asTrace) {\n      const encodedTrace = Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n      if (includeTracesContributingToStats) {\n        // For specific use inside Apollo's infrastructure to help validate that\n        // the code in this file matches similar code in Apollo's servers,\n        // include the traces that contribute to the stats. Doing this outside\n        // of Apollo's infrastructure only serves to make reports larger with no\n        // other advantage.\n        const encodedTrace = Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n\n  private getTracesAndStats(statsReportKey: string) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats());\n  }\n}\n\nclass OurTracesAndStats implements Required<ITracesAndStats> {\n  readonly trace: Uint8Array[] = [];\n  readonly statsWithContext = new StatsByContext();\n  readonly internalTracesContributingToStats: Uint8Array[] = [];\n}\n\nclass StatsByContext {\n  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);\n\n  /**\n   * This function is used by the protobuf generator to convert this map into\n   * an array of contextualized stats to serialize\n   */\n  toArray(): IContextualizedStats[] {\n    return Object.values(this.map);\n  }\n\n  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(\n      trace,\n      sizeEstimator,\n    );\n  }\n\n  private getContextualizedStats(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n  ): OurContextualizedStats {\n    const statsContext: IStatsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n      clientReferenceId: trace.clientReferenceId,\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    // Adding a ContextualizedStats means adding a StatsContext plus a\n    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;\n    // it'll be more if more features are used (like cache, APQ, etc).\n    sizeEstimator.bytes +=\n      20 +\n      estimatedBytesForString(trace.clientName) +\n      estimatedBytesForString(trace.clientVersion) +\n      estimatedBytesForString(trace.clientReferenceId);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\n\nexport class OurContextualizedStats implements Required<IContextualizedStats> {\n  queryLatencyStats = new OurQueryLatencyStats();\n  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);\n\n  constructor(readonly context: IStatsContext) {}\n\n  // Extract statistics from the trace, and increment the estimated report size.\n  // We only add to the estimate when adding whole sub-messages. If it really\n  // mattered, we could do a lot more careful things like incrementing it\n  // whenever a numeric field on queryLatencyStats gets incremented over 0.\n  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(\n        trace.durationNs,\n      );\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly\n    // calculated by the backend), not for cache hits. This matches the\n    // behavior we've had for a while when converting traces into statistics\n    // in Studio's servers.\n    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {\n      switch (trace.cachePolicy.scope) {\n        case Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n        case Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {\n      // Generate error stats and error path information\n      if (node.error?.length) {\n        hasError = true;\n\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach((subPath) => {\n          currPathErrorStats = currPathErrorStats.getChild(\n            subPath,\n            sizeEstimator,\n          );\n        });\n\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      // The actual field name behind the node; originalFieldName is set\n      // if an alias was used, otherwise responseName. (This is falsey for\n      // nodes that are not fields (root, array index, etc).)\n      const fieldName = node.originalFieldName || node.responseName;\n\n      // Protobuf doesn't really differentiate between \"unset\" and \"falsey\" so\n      // we're mostly actually checking that these things are non-empty string /\n      // non-zero numbers. The time fields represent the number of nanoseconds\n      // since the beginning of the entire trace, so let's pretend for the\n      // moment that it's plausible for a node to start or even end exactly when\n      // the trace started (ie, for the time values to be 0). This is unlikely\n      // in practice (everything should take at least 1ns). In practice we only\n      // write `type` and `parentType` on a Node when we write `startTime`, so\n      // the main thing we're looking out for by checking the time values is\n      // whether we somehow failed to write `endTime` at the end of the field;\n      // in this case, the `endTime >= startTime` check won't match.\n      if (\n        node.parentType &&\n        fieldName &&\n        node.type &&\n        node.endTime != null &&\n        node.startTime != null &&\n        node.endTime >= node.startTime\n      ) {\n        const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n\n        const fieldStat = typeStat.getFieldStat(\n          fieldName,\n          node.type,\n          sizeEstimator,\n        );\n\n        fieldStat.errorsCount += node.error?.length ?? 0;\n        fieldStat.count++;\n        // Note: this is actually counting the number of resolver calls for this\n        // field that had at least one error, not the number of overall GraphQL\n        // queries that had at least one error for this field. That doesn't seem\n        // to match the name, but it does match the other implementations of this\n        // logic.\n        fieldStat.requestsWithErrorsCount +=\n          (node.error?.length ?? 0) > 0 ? 1 : 0;\n        fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime);\n      }\n\n      return false;\n    };\n\n    iterateOverTrace(trace, traceNodeStats, true);\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\n\nclass OurQueryLatencyStats implements Required<IQueryLatencyStats> {\n  latencyCount: DurationHistogram = new DurationHistogram();\n  requestCount: number = 0;\n  cacheHits: number = 0;\n  persistedQueryHits: number = 0;\n  persistedQueryMisses: number = 0;\n  cacheLatencyCount: DurationHistogram = new DurationHistogram();\n  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();\n  requestsWithErrorsCount: number = 0;\n  publicCacheTtlCount: DurationHistogram = new DurationHistogram();\n  privateCacheTtlCount: DurationHistogram = new DurationHistogram();\n  registeredOperationCount: number = 0;\n  forbiddenOperationCount: number = 0;\n}\n\nclass OurPathErrorStats implements Required<IPathErrorStats> {\n  children: { [k: string]: OurPathErrorStats } = Object.create(null);\n  errorsCount: number = 0;\n  requestsWithErrorsCount: number = 0;\n\n  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    // Include a few bytes in the estimate for the numbers etc.\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\n\nclass OurTypeStat implements Required<ITypeStat> {\n  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);\n\n  getFieldStat(\n    fieldName: string,\n    returnType: string,\n    sizeEstimator: SizeEstimator,\n  ): OurFieldStat {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    // Rough estimate of 10 bytes for the numbers in the FieldStat.\n    sizeEstimator.bytes +=\n      estimatedBytesForString(fieldName) +\n      estimatedBytesForString(returnType) +\n      10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n}\n\nclass OurFieldStat implements Required<IFieldStat> {\n  errorsCount: number = 0;\n  count: number = 0;\n  requestsWithErrorsCount: number = 0;\n  latencyCount: DurationHistogram = new DurationHistogram();\n\n  constructor(readonly returnType: string) {}\n}\n\nfunction estimatedBytesForString(s: string) {\n  // 2 is for the tag (field ID + wire type) plus the encoded length. (The\n  // encoded length takes up more than 1 byte for strings that are longer than\n  // 127 bytes, but this is an estimate.)\n  return 2 + Buffer.byteLength(s);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}