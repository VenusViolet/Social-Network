{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ApolloServerPluginUsageReportingDisabled = exports.makeHTTPRequestHeaders = exports.ApolloServerPluginUsageReporting = void 0;\nconst os_1 = __importDefault(require(\"os\"));\nconst zlib_1 = require(\"zlib\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst apollo_graphql_1 = require(\"apollo-graphql\");\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst signatureCache_1 = require(\"./signatureCache\");\nconst traceTreeBuilder_1 = require(\"../traceTreeBuilder\");\nconst traceDetails_1 = require(\"./traceDetails\");\nconst graphql_1 = require(\"graphql\");\nconst schemaReporting_1 = require(\"../schemaReporting\");\nconst stats_1 = require(\"./stats\");\nconst apollo_cache_control_1 = require(\"apollo-cache-control\");\nconst defaultSendOperationsAsTrace_1 = require(\"./defaultSendOperationsAsTrace\");\nconst reportHeaderDefaults = {\n  hostname: os_1.default.hostname(),\n  agentVersion: `apollo-server-core@${require('../../../package.json').version}`,\n  runtimeVersion: `node ${process.version}`,\n  uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`\n};\nclass ReportData {\n  constructor(executableSchemaId, graphRef) {\n    this.header = new apollo_reporting_protobuf_1.ReportHeader(Object.assign(Object.assign({}, reportHeaderDefaults), {\n      executableSchemaId,\n      graphRef\n    }));\n    this.reset();\n  }\n  reset() {\n    this.report = new stats_1.OurReport(this.header);\n  }\n}\nfunction ApolloServerPluginUsageReporting() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.create(null);\n  let requestDidStartHandler;\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n    requestDidStart(requestContext) {\n      if (!requestDidStartHandler) {\n        throw Error('The usage reporting plugin has been asked to handle a request before the ' + 'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' + 'for more details.');\n      }\n      return requestDidStartHandler(requestContext);\n    },\n    serverWillStart(_ref) {\n      let {\n        logger: serverLogger,\n        apollo,\n        serverlessFramework\n      } = _ref;\n      var _a, _b, _c, _d;\n      const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : serverLogger;\n      const {\n        key,\n        graphRef\n      } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" + 'but you also need to provide your Apollo API key and graph ref, via ' + 'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' + 'variables or via `new ApolloServer({apollo: {key, graphRef})`.');\n      }\n      logger.info('Apollo usage reporting starting! See your graph at ' + `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);\n      const sendReportsImmediately = (_b = options.sendReportsImmediately) !== null && _b !== void 0 ? _b : serverlessFramework;\n      const signatureCache = signatureCache_1.createSignatureCache({\n        logger\n      });\n      const reportDataByExecutableSchemaId = Object.create(null);\n      const overriddenExecutableSchemaId = options.overrideReportedSchema ? schemaReporting_1.computeCoreSchemaHash(options.overrideReportedSchema) : undefined;\n      let lastSeenExecutableSchemaToId;\n      let reportTimer;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1000);\n      }\n      let graphMightSupportTraces = true;\n      const sendOperationAsTrace = (_c = options.experimental_sendOperationAsTrace) !== null && _c !== void 0 ? _c : defaultSendOperationsAsTrace_1.defaultSendOperationsAsTrace();\n      const includeTracesContributingToStats = (_d = options.internal_includeTracesContributingToStats) !== null && _d !== void 0 ? _d : false;\n      let stopped = false;\n      function executableSchemaIdForSchema(schema) {\n        if ((lastSeenExecutableSchemaToId === null || lastSeenExecutableSchemaToId === void 0 ? void 0 : lastSeenExecutableSchemaToId.executableSchema) === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = schemaReporting_1.computeCoreSchemaHash(graphql_1.printSchema(schema));\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id\n        };\n        return id;\n      }\n      const getReportData = executableSchemaId => {\n        const existing = reportDataByExecutableSchemaId[executableSchemaId];\n        if (existing) {\n          return existing;\n        }\n        const reportData = new ReportData(executableSchemaId, graphRef);\n        reportDataByExecutableSchemaId[executableSchemaId] = reportData;\n        return reportData;\n      };\n      function sendAllReportsAndReportErrors() {\n        return __awaiter(this, void 0, void 0, function* () {\n          yield Promise.all(Object.keys(reportDataByExecutableSchemaId).map(executableSchemaId => sendReportAndReportErrors(executableSchemaId)));\n        });\n      }\n      function sendReportAndReportErrors(executableSchemaId) {\n        return __awaiter(this, void 0, void 0, function* () {\n          return sendReport(executableSchemaId).catch(err => {\n            if (options.reportErrorFunction) {\n              options.reportErrorFunction(err);\n            } else {\n              logger.error(err.message);\n            }\n          });\n        });\n      }\n      const sendReport = executableSchemaId => __awaiter(this, void 0, void 0, function* () {\n        var _e, _f;\n        const reportData = getReportData(executableSchemaId);\n        const {\n          report\n        } = reportData;\n        reportData.reset();\n        if (Object.keys(report.tracesPerQuery).length === 0) {\n          return;\n        }\n        report.endTime = traceTreeBuilder_1.dateToProtoTimestamp(new Date());\n        const protobufError = apollo_reporting_protobuf_1.Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error encoding report: ${protobufError}`);\n        }\n        const message = apollo_reporting_protobuf_1.Report.encode(report).finish();\n        if (options.debugPrintReports) {\n          const decodedReport = apollo_reporting_protobuf_1.Report.decode(message);\n          logger.warn(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);\n        }\n        const compressed = yield new Promise((resolve, reject) => {\n          const messageBuffer = Buffer.from(message.buffer, message.byteOffset, message.byteLength);\n          zlib_1.gzip(messageBuffer, (err, gzipResult) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(gzipResult);\n            }\n          });\n        });\n        const fetcher = (_e = options.fetcher) !== null && _e !== void 0 ? _e : apollo_server_env_1.fetch;\n        const response = yield async_retry_1.default(() => __awaiter(this, void 0, void 0, function* () {\n          const curResponse = yield fetcher((options.endpointUrl || 'https://usage-reporting.api.apollographql.com') + '/api/ingress/traces', {\n            method: 'POST',\n            headers: {\n              'user-agent': 'ApolloServerPluginUsageReporting',\n              'x-api-key': key,\n              'content-encoding': 'gzip',\n              accept: 'application/json'\n            },\n            body: compressed,\n            agent: options.requestAgent\n          });\n          if (curResponse.status >= 500 && curResponse.status < 600) {\n            throw new Error(`HTTP status ${curResponse.status}, ${(yield curResponse.text()) || '(no body)'}`);\n          } else {\n            return curResponse;\n          }\n        }), {\n          retries: (options.maxAttempts || 5) - 1,\n          minTimeout: options.minimumRetryDelayMs || 100,\n          factor: 2\n        }).catch(err => {\n          throw new Error(`Error sending report to Apollo servers: ${err.message}`);\n        });\n        if (response.status < 200 || response.status >= 300) {\n          throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${(yield response.text()) || '(no body)'}`);\n        }\n        if (graphMightSupportTraces && response.status === 200 && ((_f = response.headers.get('content-type')) === null || _f === void 0 ? void 0 : _f.match(/^\\s*application\\/json\\s*(?:;|$)/i))) {\n          const body = yield response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\"This graph's organization does not have access to traces; sending all \" + 'subsequent operations as traces.');\n            graphMightSupportTraces = false;\n          }\n        }\n        if (options.debugPrintReports) {\n          logger.warn(`Apollo usage report: status ${response.status}`);\n        }\n      });\n      requestDidStartHandler = _ref2 => {\n        let {\n          logger: requestLogger,\n          metrics,\n          schema,\n          request: {\n            http,\n            variables\n          }\n        } = _ref2;\n        var _a;\n        const logger = (_a = requestLogger !== null && requestLogger !== void 0 ? requestLogger : options.logger) !== null && _a !== void 0 ? _a : serverLogger;\n        const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({\n          rewriteError: options.rewriteError,\n          logger\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        if (http) {\n          treeBuilder.trace.http = new apollo_reporting_protobuf_1.Trace.HTTP({\n            method: apollo_reporting_protobuf_1.Trace.HTTP.Method[http.method] || apollo_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN,\n            host: null,\n            path: null\n          });\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);\n          }\n        }\n        function shouldIncludeRequest(requestContext) {\n          return __awaiter(this, void 0, void 0, function* () {\n            if (metrics.captureTraces !== undefined) return;\n            if (typeof options.includeRequest !== 'function') {\n              metrics.captureTraces = true;\n              return;\n            }\n            metrics.captureTraces = yield options.includeRequest(requestContext);\n            if (typeof metrics.captureTraces !== 'boolean') {\n              logger.warn(\"The 'includeRequest' async predicate function must return a boolean value.\");\n              metrics.captureTraces = true;\n            }\n          });\n        }\n        let endDone = false;\n        function didEnd(requestContext) {\n          if (endDone) return;\n          endDone = true;\n          treeBuilder.stopTiming();\n          if (metrics.captureTraces === undefined) {\n            logger.warn('captureTrace is undefined at the end of the request. This is a bug in ApolloServerPluginUsageReporting.');\n          }\n          if (metrics.captureTraces === false) return;\n          treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n          treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n          treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;\n          if (requestContext.overallCachePolicy) {\n            treeBuilder.trace.cachePolicy = new apollo_reporting_protobuf_1.Trace.CachePolicy({\n              scope: requestContext.overallCachePolicy.scope === apollo_cache_control_1.CacheScope.Private ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE : requestContext.overallCachePolicy.scope === apollo_cache_control_1.CacheScope.Public ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC : apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,\n              maxAgeNs: requestContext.overallCachePolicy.maxAge * 1e9\n            });\n          }\n          const operationName = requestContext.operationName || requestContext.request.operationName || '';\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n          addTrace().catch(logger.error);\n          function addTrace() {\n            return __awaiter(this, void 0, void 0, function* () {\n              if (stopped) {\n                return;\n              }\n              yield new Promise(res => setImmediate(res));\n              const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);\n              const reportData = getReportData(executableSchemaId);\n              const {\n                report\n              } = reportData;\n              const {\n                trace\n              } = treeBuilder;\n              let statsReportKey = undefined;\n              if (!requestContext.document) {\n                statsReportKey = `## GraphQLParseFailure\\n`;\n              } else if (graphqlValidationFailure) {\n                statsReportKey = `## GraphQLValidationFailure\\n`;\n              } else if (graphqlUnknownOperationName) {\n                statsReportKey = `## GraphQLUnknownOperationName\\n`;\n              }\n              if (statsReportKey) {\n                if (options.sendUnexecutableOperationDocuments) {\n                  trace.unexecutedOperationBody = requestContext.source;\n                  trace.unexecutedOperationName = operationName;\n                }\n              } else {\n                const signature = getTraceSignature();\n                statsReportKey = `# ${operationName || '-'}\\n${signature}`;\n              }\n              const protobufError = apollo_reporting_protobuf_1.Trace.verify(trace);\n              if (protobufError) {\n                throw new Error(`Error encoding trace: ${protobufError}`);\n              }\n              report.addTrace({\n                statsReportKey,\n                trace,\n                asTrace: graphMightSupportTraces && sendOperationAsTrace(trace, statsReportKey),\n                includeTracesContributingToStats\n              });\n              if (sendReportsImmediately || report.sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {\n                yield sendReportAndReportErrors(executableSchemaId);\n              }\n            });\n          }\n          function getTraceSignature() {\n            if (!requestContext.document) {\n              throw new Error('No document?');\n            }\n            const cacheKey = signatureCache_1.signatureCacheKey(requestContext.queryHash, operationName);\n            const cachedSignature = signatureCache.get(cacheKey);\n            if (cachedSignature) {\n              return cachedSignature;\n            }\n            const generatedSignature = (options.calculateSignature || apollo_graphql_1.defaultUsageReportingSignature)(requestContext.document, operationName);\n            signatureCache.set(cacheKey, generatedSignature);\n            return generatedSignature;\n          }\n        }\n        let didResolveSource = false;\n        return {\n          didResolveSource(requestContext) {\n            didResolveSource = true;\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n            if (variables) {\n              treeBuilder.trace.details = traceDetails_1.makeTraceDetails(variables, options.sendVariableValues, requestContext.source);\n            }\n            const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);\n            if (clientInfo) {\n              const {\n                clientName,\n                clientVersion,\n                clientReferenceId\n              } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientReferenceId = clientReferenceId || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          validationDidStart() {\n            return validationErrors => {\n              graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;\n            };\n          },\n          didResolveOperation(requestContext) {\n            return __awaiter(this, void 0, void 0, function* () {\n              graphqlUnknownOperationName = requestContext.operation === undefined;\n              yield shouldIncludeRequest(requestContext);\n              if (metrics.captureTraces === false) {\n                didEnd(requestContext);\n              }\n            });\n          },\n          executionDidStart() {\n            if (endDone) return;\n            return {\n              willResolveField(_ref3) {\n                let {\n                  info\n                } = _ref3;\n                return treeBuilder.willResolveField(info);\n              }\n            };\n          },\n          willSendResponse(requestContext) {\n            didEnd(requestContext);\n          },\n          didEncounterErrors(requestContext) {\n            return __awaiter(this, void 0, void 0, function* () {\n              if (!didResolveSource || endDone) return;\n              treeBuilder.didEncounterErrors(requestContext.errors);\n              yield shouldIncludeRequest(requestContext);\n              didEnd(requestContext);\n            });\n          }\n        };\n      };\n      return {\n        serverWillStop() {\n          return __awaiter(this, void 0, void 0, function* () {\n            if (reportTimer) {\n              clearInterval(reportTimer);\n              reportTimer = undefined;\n            }\n            stopped = true;\n            yield sendAllReportsAndReportErrors();\n          });\n        }\n      };\n    }\n  };\n}\nexports.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;\nfunction makeHTTPRequestHeaders(http, headers, sendHeaders) {\n  if (!sendHeaders || 'none' in sendHeaders && sendHeaders.none || 'all' in sendHeaders && !sendHeaders.all) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    const lowerCaseKey = key.toLowerCase();\n    if ('exceptNames' in sendHeaders && sendHeaders.exceptNames.some(exceptHeader => {\n      return exceptHeader.toLowerCase() === lowerCaseKey;\n    }) || 'onlyNames' in sendHeaders && !sendHeaders.onlyNames.some(header => {\n      return header.toLowerCase() === lowerCaseKey;\n    })) {\n      continue;\n    }\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http.requestHeaders[key] = new apollo_reporting_protobuf_1.Trace.HTTP.Values({\n          value: [value]\n        });\n    }\n  }\n}\nexports.makeHTTPRequestHeaders = makeHTTPRequestHeaders;\nfunction defaultGenerateClientInfo(_ref4) {\n  let {\n    request\n  } = _ref4;\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientReferenceIdHeaderKey = 'apollographql-client-reference-id';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n  if (((_b = (_a = request.http) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.get(clientNameHeaderKey)) || ((_d = (_c = request.http) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.get(clientVersionHeaderKey)) || ((_f = (_e = request.http) === null || _e === void 0 ? void 0 : _e.headers) === null || _f === void 0 ? void 0 : _f.get(clientReferenceIdHeaderKey))) {\n    return {\n      clientName: (_h = (_g = request.http) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h.get(clientNameHeaderKey),\n      clientVersion: (_k = (_j = request.http) === null || _j === void 0 ? void 0 : _j.headers) === null || _k === void 0 ? void 0 : _k.get(clientVersionHeaderKey),\n      clientReferenceId: (_m = (_l = request.http) === null || _l === void 0 ? void 0 : _l.headers) === null || _m === void 0 ? void 0 : _m.get(clientReferenceIdHeaderKey)\n    };\n  } else if ((_o = request.extensions) === null || _o === void 0 ? void 0 : _o.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\nfunction ApolloServerPluginUsageReportingDisabled() {\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    }\n  };\n}\nexports.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;","map":{"version":3,"names":["os_1","__importDefault","require","zlib_1","async_retry_1","apollo_graphql_1","apollo_reporting_protobuf_1","apollo_server_env_1","signatureCache_1","traceTreeBuilder_1","traceDetails_1","graphql_1","schemaReporting_1","stats_1","apollo_cache_control_1","defaultSendOperationsAsTrace_1","reportHeaderDefaults","hostname","default","agentVersion","version","runtimeVersion","process","uname","platform","type","release","arch","ReportData","constructor","executableSchemaId","graphRef","header","ReportHeader","Object","assign","reset","report","OurReport","ApolloServerPluginUsageReporting","options","arguments","length","undefined","create","requestDidStartHandler","__internal_plugin_id__","requestDidStart","requestContext","Error","serverWillStart","_ref","logger","serverLogger","apollo","serverlessFramework","_a","key","info","encodeURI","sendReportsImmediately","_b","signatureCache","createSignatureCache","reportDataByExecutableSchemaId","overriddenExecutableSchemaId","overrideReportedSchema","computeCoreSchemaHash","lastSeenExecutableSchemaToId","reportTimer","setInterval","sendAllReportsAndReportErrors","reportIntervalMs","graphMightSupportTraces","sendOperationAsTrace","_c","experimental_sendOperationAsTrace","defaultSendOperationsAsTrace","includeTracesContributingToStats","_d","internal_includeTracesContributingToStats","stopped","executableSchemaIdForSchema","schema","executableSchema","id","printSchema","getReportData","existing","reportData","Promise","all","keys","map","sendReportAndReportErrors","sendReport","catch","err","reportErrorFunction","error","message","__awaiter","tracesPerQuery","endTime","dateToProtoTimestamp","Date","protobufError","Report","verify","encode","finish","debugPrintReports","decodedReport","decode","warn","JSON","stringify","toJSON","compressed","resolve","reject","messageBuffer","Buffer","from","buffer","byteOffset","byteLength","gzip","gzipResult","fetcher","_e","fetch","response","curResponse","endpointUrl","method","headers","accept","body","agent","requestAgent","status","text","retries","maxAttempts","minTimeout","minimumRetryDelayMs","factor","_f","get","match","parsedBody","parse","e","tracesIgnored","debug","_ref2","requestLogger","metrics","request","http","variables","treeBuilder","TraceTreeBuilder","rewriteError","startTiming","startHrTime","graphqlValidationFailure","graphqlUnknownOperationName","trace","Trace","HTTP","Method","UNKNOWN","host","path","sendHeaders","makeHTTPRequestHeaders","shouldIncludeRequest","captureTraces","includeRequest","endDone","didEnd","stopTiming","fullQueryCacheHit","responseCacheHit","forbiddenOperation","registeredOperation","overallCachePolicy","cachePolicy","CachePolicy","scope","CacheScope","Private","Scope","PRIVATE","Public","PUBLIC","maxAgeNs","maxAge","operationName","queryPlanTrace","queryPlan","addTrace","res","setImmediate","statsReportKey","document","sendUnexecutableOperationDocuments","unexecutedOperationBody","source","unexecutedOperationName","signature","getTraceSignature","asTrace","sizeEstimator","bytes","maxUncompressedReportSize","cacheKey","signatureCacheKey","queryHash","cachedSignature","generatedSignature","calculateSignature","defaultUsageReportingSignature","set","didResolveSource","persistedQueryHit","persistedQueryRegister","details","makeTraceDetails","sendVariableValues","clientInfo","generateClientInfo","defaultGenerateClientInfo","clientName","clientVersion","clientReferenceId","validationDidStart","validationErrors","didResolveOperation","operation","executionDidStart","willResolveField","_ref3","willSendResponse","didEncounterErrors","errors","serverWillStop","clearInterval","exports","none","value","lowerCaseKey","toLowerCase","exceptNames","some","exceptHeader","onlyNames","requestHeaders","Values","_ref4","clientNameHeaderKey","clientReferenceIdHeaderKey","clientVersionHeaderKey","_h","_g","_k","_j","_m","_l","_o","extensions","ApolloServerPluginUsageReportingDisabled"],"sources":["/Users/venusrodin/node_modules/apollo-server-core/src/plugin/usageReporting/plugin.ts"],"sourcesContent":["import os from 'os';\nimport { gzip } from 'zlib';\nimport retry from 'async-retry';\nimport { defaultUsageReportingSignature } from 'apollo-graphql';\nimport { Report, ReportHeader, Trace } from 'apollo-reporting-protobuf';\nimport { Response, fetch, Headers } from 'apollo-server-env';\nimport {\n  GraphQLRequestListener,\n  GraphQLServerListener,\n} from 'apollo-server-plugin-base';\nimport {\n  GraphQLRequestContext,\n  GraphQLServiceContext,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestContextDidResolveSource,\n} from 'apollo-server-types';\nimport { createSignatureCache, signatureCacheKey } from './signatureCache';\nimport {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n} from './options';\nimport { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder';\nimport { makeTraceDetails } from './traceDetails';\nimport { GraphQLSchema, printSchema } from 'graphql';\nimport { computeCoreSchemaHash } from '../schemaReporting';\nimport type { InternalApolloServerPlugin } from '../internalPlugin';\nimport { OurReport } from './stats';\nimport { CacheScope } from 'apollo-cache-control';\nimport { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace';\n\nconst reportHeaderDefaults = {\n  hostname: os.hostname(),\n  agentVersion: `apollo-server-core@${\n    require('../../../package.json').version\n  }`,\n  runtimeVersion: `node ${process.version}`,\n  // XXX not actually uname, but what node has easily.\n  uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,\n};\n\nclass ReportData {\n  report!: OurReport;\n  readonly header: ReportHeader;\n  constructor(executableSchemaId: string, graphRef: string) {\n    this.header = new ReportHeader({\n      ...reportHeaderDefaults,\n      executableSchemaId,\n      graphRef,\n    });\n    this.reset();\n  }\n  reset() {\n    this.report = new OurReport(this.header);\n  }\n}\n\nexport function ApolloServerPluginUsageReporting<TContext>(\n  options: ApolloServerPluginUsageReportingOptions<TContext> = Object.create(\n    null,\n  ),\n): InternalApolloServerPlugin {\n  let requestDidStartHandler: (\n    requestContext: GraphQLRequestContext<TContext>,\n  ) => GraphQLRequestListener<TContext>;\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n\n    // We want to be able to access locals from `serverWillStart` in our `requestDidStart`, thus\n    // this little hack. (Perhaps we should also allow GraphQLServerListener to contain\n    // a requestDidStart?)\n    requestDidStart(requestContext: GraphQLRequestContext<TContext>) {\n      if (!requestDidStartHandler) {\n        throw Error(\n          'The usage reporting plugin has been asked to handle a request before the ' +\n            'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' +\n            'for more details.',\n        );\n      }\n      return requestDidStartHandler(requestContext);\n    },\n\n    serverWillStart({\n      logger: serverLogger,\n      apollo,\n      serverlessFramework,\n    }: GraphQLServiceContext): GraphQLServerListener {\n      // Use the plugin-specific logger if one is provided; otherwise the general server one.\n      const logger = options.logger ?? serverLogger;\n      const { key, graphRef } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\n          \"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" +\n            'but you also need to provide your Apollo API key and graph ref, via ' +\n            'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +\n            'variables or via `new ApolloServer({apollo: {key, graphRef})`.',\n        );\n      }\n\n      logger.info(\n        'Apollo usage reporting starting! See your graph at ' +\n          `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`,\n      );\n\n      // If sendReportsImmediately is not specified, we default to true if we're running\n      // with the ApolloServer designed for Lambda or similar. That's because these\n      // environments aren't designed around letting us run a background task to\n      // send reports later or hook into container destruction to flush buffered reports.\n      const sendReportsImmediately =\n        options.sendReportsImmediately ?? serverlessFramework;\n\n      // Since calculating the signature for usage reporting is potentially an\n      // expensive operation, we'll cache the signatures we generate and re-use\n      // them based on repeated traces for the same `queryHash`.\n      const signatureCache = createSignatureCache({ logger });\n\n      const reportDataByExecutableSchemaId: {\n        [executableSchemaId: string]: ReportData | undefined;\n      } = Object.create(null);\n\n      const overriddenExecutableSchemaId = options.overrideReportedSchema\n        ? computeCoreSchemaHash(options.overrideReportedSchema)\n        : undefined;\n\n      let lastSeenExecutableSchemaToId:\n        | {\n            executableSchema: GraphQLSchema;\n            executableSchemaId: string;\n          }\n        | undefined;\n\n      let reportTimer: NodeJS.Timer | undefined;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(\n          () => sendAllReportsAndReportErrors(),\n          options.reportIntervalMs || 10 * 1000,\n        );\n      }\n\n      let graphMightSupportTraces = true;\n      const sendOperationAsTrace =\n        options.experimental_sendOperationAsTrace ??\n        defaultSendOperationsAsTrace();\n      const includeTracesContributingToStats =\n        options.internal_includeTracesContributingToStats ?? false;\n\n      let stopped = false;\n\n      function executableSchemaIdForSchema(schema: GraphQLSchema) {\n        if (lastSeenExecutableSchemaToId?.executableSchema === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = computeCoreSchemaHash(printSchema(schema));\n\n        // We override this variable every time we get a new schema so we cache\n        // the last seen value. It is a single-entry cache.\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id,\n        };\n\n        return id;\n      }\n\n      const getReportData = (executableSchemaId: string): ReportData => {\n        const existing = reportDataByExecutableSchemaId[executableSchemaId];\n        if (existing) {\n          return existing;\n        }\n        const reportData = new ReportData(executableSchemaId, graphRef);\n        reportDataByExecutableSchemaId[executableSchemaId] = reportData;\n        return reportData;\n      };\n\n      async function sendAllReportsAndReportErrors(): Promise<void> {\n        await Promise.all(\n          Object.keys(\n            reportDataByExecutableSchemaId,\n          ).map((executableSchemaId) =>\n            sendReportAndReportErrors(executableSchemaId),\n          ),\n        );\n      }\n\n      async function sendReportAndReportErrors(\n        executableSchemaId: string,\n      ): Promise<void> {\n        return sendReport(executableSchemaId).catch((err) => {\n          // This catch block is primarily intended to catch network errors from\n          // the retried request itself, which include network errors and non-2xx\n          // HTTP errors.\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n\n      // Needs to be an arrow function to be confident that key is defined.\n      const sendReport = async (executableSchemaId: string): Promise<void> => {\n        const reportData = getReportData(executableSchemaId);\n        const { report } = reportData;\n        reportData.reset();\n\n        if (Object.keys(report.tracesPerQuery).length === 0) {\n          return;\n        }\n\n        // Set the report's overall end time. This is the timestamp that will be\n        // associated with the summarized statistics.\n        report.endTime = dateToProtoTimestamp(new Date());\n\n        const protobufError = Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error encoding report: ${protobufError}`);\n        }\n        const message = Report.encode(report).finish();\n\n        // Potential follow-up: we can compare message.length to\n        // report.sizeEstimator.bytes and use it to \"learn\" if our estimation is\n        // off and adjust it based on what we learn.\n\n        if (options.debugPrintReports) {\n          // In terms of verbosity, and as the name of this option suggests,\n          // this message is either an \"info\" or a \"debug\" level message.\n          // However, we are using `warn` here for compatibility reasons since\n          // the `debugPrintReports` flag pre-dated the existence of log-levels\n          // and changing this to also require `debug: true` (in addition to\n          // `debugPrintReports`) just to reach the level of verbosity to\n          // produce the output would be a breaking change.  The \"warn\" level is\n          // on by default.  There is a similar theory and comment applied\n          // below.\n          //\n          // We decode the report rather than printing the original `report`\n          // so that it includes all of the pre-encoded traces.\n          const decodedReport = Report.decode(message);\n          logger.warn(\n            `Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`,\n          );\n        }\n\n        const compressed = await new Promise<Buffer>((resolve, reject) => {\n          // The protobuf library gives us a Uint8Array. Node 8's zlib lets us\n          // pass it directly; convert for the sake of Node 6. (No support right\n          // now for Node 4, which lacks Buffer.from.)\n          const messageBuffer = Buffer.from(\n            message.buffer as ArrayBuffer,\n            message.byteOffset,\n            message.byteLength,\n          );\n          gzip(messageBuffer, (err, gzipResult) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(gzipResult);\n            }\n          });\n        });\n\n        // Wrap fetcher with async-retry for automatic retrying\n        const fetcher = options.fetcher ?? fetch;\n        const response: Response = await retry(\n          // Retry on network errors and 5xx HTTP\n          // responses.\n          async () => {\n            const curResponse = await fetcher(\n              (options.endpointUrl ||\n                'https://usage-reporting.api.apollographql.com') +\n                '/api/ingress/traces',\n              {\n                method: 'POST',\n                headers: {\n                  'user-agent': 'ApolloServerPluginUsageReporting',\n                  'x-api-key': key,\n                  'content-encoding': 'gzip',\n                  accept: 'application/json',\n                },\n                body: compressed,\n                agent: options.requestAgent,\n              },\n            );\n\n            if (curResponse.status >= 500 && curResponse.status < 600) {\n              throw new Error(\n                `HTTP status ${curResponse.status}, ${\n                  (await curResponse.text()) || '(no body)'\n                }`,\n              );\n            } else {\n              return curResponse;\n            }\n          },\n          {\n            retries: (options.maxAttempts || 5) - 1,\n            minTimeout: options.minimumRetryDelayMs || 100,\n            factor: 2,\n          },\n        ).catch((err: Error) => {\n          throw new Error(\n            `Error sending report to Apollo servers: ${err.message}`,\n          );\n        });\n\n        if (response.status < 200 || response.status >= 300) {\n          // Note that we don't expect to see a 3xx here because request follows\n          // redirects.\n          throw new Error(\n            `Error sending report to Apollo servers: HTTP status ${\n              response.status\n            }, ${(await response.text()) || '(no body)'}`,\n          );\n        }\n\n        if (\n          graphMightSupportTraces &&\n          response.status === 200 &&\n          response.headers\n            .get('content-type')\n            ?.match(/^\\s*application\\/json\\s*(?:;|$)/i)\n        ) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\n              \"This graph's organization does not have access to traces; sending all \" +\n                'subsequent operations as traces.',\n            );\n            graphMightSupportTraces = false;\n            // XXX We could also parse traces that are already in the current\n            // report and convert them to stats if we wanted?\n          }\n        }\n        if (options.debugPrintReports) {\n          // In terms of verbosity, and as the name of this option suggests, this\n          // message is either an \"info\" or a \"debug\" level message.  However,\n          // we are using `warn` here for compatibility reasons since the\n          // `debugPrintReports` flag pre-dated the existence of log-levels and\n          // changing this to also require `debug: true` (in addition to\n          // `debugPrintReports`) just to reach the level of verbosity to produce\n          // the output would be a breaking change.  The \"warn\" level is on by\n          // default.  There is a similar theory and comment applied above.\n          logger.warn(`Apollo usage report: status ${response.status}`);\n        }\n      };\n\n      requestDidStartHandler = ({\n        logger: requestLogger,\n        metrics,\n        schema,\n        request: { http, variables },\n      }): GraphQLRequestListener<TContext> => {\n        // Request specific log output should go into the `logger` from the\n        // request context when it's provided.\n        const logger = requestLogger ?? options.logger ?? serverLogger;\n        const treeBuilder: TraceTreeBuilder = new TraceTreeBuilder({\n          rewriteError: options.rewriteError,\n          logger,\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n\n        if (http) {\n          treeBuilder.trace.http = new Trace.HTTP({\n            method:\n              Trace.HTTP.Method[\n                http.method as keyof typeof Trace.HTTP.Method\n              ] || Trace.HTTP.Method.UNKNOWN,\n            // Host and path are not used anywhere on the backend, so let's not bother\n            // trying to parse request.url to get them, which is a potential\n            // source of bugs because integrations have different behavior here.\n            // On Node's HTTP module, request.url only includes the path\n            // (see https://nodejs.org/api/http.html#http_message_url)\n            // The same is true on Lambda (where we pass event.path)\n            // But on environments like Cloudflare we do get a complete URL.\n            host: null,\n            path: null,\n          });\n\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(\n              treeBuilder.trace.http,\n              http.headers,\n              options.sendHeaders,\n            );\n          }\n        }\n\n        async function shouldIncludeRequest(\n          requestContext:\n            | GraphQLRequestContextDidResolveOperation<TContext>\n            | GraphQLRequestContextDidEncounterErrors<TContext>,\n        ): Promise<void> {\n          // This could be hit if we call `shouldIncludeRequest` more than once during a request.\n          // such as if `didEncounterError` gets called after `didResolveOperation`.\n          if (metrics.captureTraces !== undefined) return;\n\n          if (typeof options.includeRequest !== 'function') {\n            // Default case we always report\n            metrics.captureTraces = true;\n            return;\n          }\n\n          metrics.captureTraces = await options.includeRequest(requestContext);\n\n          // Help the user understand they've returned an unexpected value,\n          // which might be a subtle mistake.\n          if (typeof metrics.captureTraces !== 'boolean') {\n            logger.warn(\n              \"The 'includeRequest' async predicate function must return a boolean value.\",\n            );\n            metrics.captureTraces = true;\n          }\n        }\n\n        /**\n         * Due to a number of exceptions in the request pipeline — which are\n         * intended to preserve backwards compatible behavior with the\n         * first generation of the request pipeline plugins prior to the\n         * introduction of `didEncounterErrors` — we need to have this \"didEnd\"\n         * functionality invoked from two places.  This accounts for the fact\n         * that sometimes, under some special-cased error conditions,\n         * `willSendResponse` is not invoked.  To zoom in on some of these cases,\n         * check the `requestPipeline.ts` for `emitErrorAndThrow`.\n         */\n        let endDone: boolean = false;\n        function didEnd(\n          requestContext:\n            | GraphQLRequestContextWillSendResponse<TContext>\n            // Our didEncounterErrors handler only calls this function if didResolveSource.\n            | (GraphQLRequestContextDidEncounterErrors<TContext> &\n                GraphQLRequestContextDidResolveSource<TContext>)\n            | GraphQLRequestContextDidResolveOperation<TContext>,\n        ) {\n          if (endDone) return;\n          endDone = true;\n          treeBuilder.stopTiming();\n\n          if (metrics.captureTraces === undefined) {\n            logger.warn(\n              'captureTrace is undefined at the end of the request. This is a bug in ApolloServerPluginUsageReporting.',\n            );\n          }\n\n          if (metrics.captureTraces === false) return;\n\n          treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n          treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n          treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;\n\n          if (requestContext.overallCachePolicy) {\n            treeBuilder.trace.cachePolicy = new Trace.CachePolicy({\n              scope:\n                requestContext.overallCachePolicy.scope === CacheScope.Private\n                  ? Trace.CachePolicy.Scope.PRIVATE\n                  : requestContext.overallCachePolicy.scope ===\n                    CacheScope.Public\n                  ? Trace.CachePolicy.Scope.PUBLIC\n                  : Trace.CachePolicy.Scope.UNKNOWN,\n              // Convert from seconds to ns.\n              maxAgeNs: requestContext.overallCachePolicy.maxAge * 1e9,\n            });\n          }\n\n          // If operation resolution (parsing and validating the document followed\n          // by selecting the correct operation) resulted in the population of the\n          // `operationName`, we'll use that. (For anonymous operations,\n          // `requestContext.operationName` is null, which we represent here as\n          // the empty string.)\n          //\n          // If the user explicitly specified an `operationName` in their request\n          // but operation resolution failed (due to parse or validation errors or\n          // because there is no operation with that name in the document), we\n          // still put _that_ user-supplied `operationName` in the trace. This\n          // allows the error to be better understood in Studio. (We are\n          // considering changing the behavior of `operationName` in these 3 error\n          // cases; https://github.com/apollographql/apollo-server/pull/3465)\n          const operationName =\n            requestContext.operationName ||\n            requestContext.request.operationName ||\n            '';\n\n          // If this was a federated operation and we're the gateway, add the query plan\n          // to the trace.\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n\n          // Intentionally un-awaited so as not to block the response.  Any\n          // errors will be logged, but will not manifest a user-facing error.\n          // The logger in this case is a request specific logger OR the logger\n          // defined by the plugin if that's unavailable.  The request-specific\n          // logger is preferred since this is very much coupled directly to a\n          // client-triggered action which might be more granularly tagged by\n          // logging implementations.\n          addTrace().catch(logger.error);\n\n          async function addTrace(): Promise<void> {\n            // Ignore traces that come in after stop().\n            if (stopped) {\n              return;\n            }\n\n            // Ensure that the caller of addTrace (which does not await it) is\n            // not blocked. We use setImmediate rather than process.nextTick or\n            // just relying on the Promise microtask queue because setImmediate\n            // comes after IO, which is what we want.\n            await new Promise((res) => setImmediate(res));\n\n            const executableSchemaId =\n              overriddenExecutableSchemaId ??\n              executableSchemaIdForSchema(schema);\n\n            const reportData = getReportData(executableSchemaId);\n            const { report } = reportData;\n            const { trace } = treeBuilder;\n\n            let statsReportKey: string | undefined = undefined;\n            if (!requestContext.document) {\n              statsReportKey = `## GraphQLParseFailure\\n`;\n            } else if (graphqlValidationFailure) {\n              statsReportKey = `## GraphQLValidationFailure\\n`;\n            } else if (graphqlUnknownOperationName) {\n              statsReportKey = `## GraphQLUnknownOperationName\\n`;\n            }\n\n            if (statsReportKey) {\n              if (options.sendUnexecutableOperationDocuments) {\n                trace.unexecutedOperationBody = requestContext.source;\n                trace.unexecutedOperationName = operationName;\n              }\n            } else {\n              const signature = getTraceSignature();\n              statsReportKey = `# ${operationName || '-'}\\n${signature}`;\n            }\n\n            const protobufError = Trace.verify(trace);\n            if (protobufError) {\n              throw new Error(`Error encoding trace: ${protobufError}`);\n            }\n\n            report.addTrace({\n              statsReportKey,\n              trace,\n              asTrace:\n                graphMightSupportTraces &&\n                sendOperationAsTrace(trace, statsReportKey),\n              includeTracesContributingToStats,\n            });\n\n            // If the buffer gets big (according to our estimate), send.\n            if (\n              sendReportsImmediately ||\n              report.sizeEstimator.bytes >=\n                (options.maxUncompressedReportSize || 4 * 1024 * 1024)\n            ) {\n              await sendReportAndReportErrors(executableSchemaId);\n            }\n          }\n\n          function getTraceSignature(): string {\n            if (!requestContext.document) {\n              // This shouldn't happen: no document means parse failure, which\n              // uses its own special statsReportKey.\n              throw new Error('No document?');\n            }\n\n            const cacheKey = signatureCacheKey(\n              requestContext.queryHash,\n              operationName,\n            );\n\n            // If we didn't have the signature in the cache, we'll resort to\n            // calculating it.\n            const cachedSignature = signatureCache.get(cacheKey);\n\n            if (cachedSignature) {\n              return cachedSignature;\n            }\n\n            const generatedSignature = (\n              options.calculateSignature || defaultUsageReportingSignature\n            )(requestContext.document, operationName);\n\n            // Note that this cache is always an in-memory cache.\n            // If we replace it with a more generic async cache, we should\n            // not await the write operation.\n            signatureCache.set(cacheKey, generatedSignature);\n\n            return generatedSignature;\n          }\n        }\n\n        // While we start the tracing as soon as possible, we only actually report\n        // traces when we have resolved the source.  This is largely because of\n        // the APQ negotiation that takes place before that resolution happens.\n        // This is effectively bypassing the reporting of:\n        //   - PersistedQueryNotFoundError\n        //   - PersistedQueryNotSupportedError\n        //   - InvalidGraphQLRequestError\n        let didResolveSource: boolean = false;\n\n        return {\n          didResolveSource(requestContext) {\n            didResolveSource = true;\n\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n\n            if (variables) {\n              treeBuilder.trace.details = makeTraceDetails(\n                variables,\n                options.sendVariableValues,\n                requestContext.source,\n              );\n            }\n\n            const clientInfo = (\n              options.generateClientInfo || defaultGenerateClientInfo\n            )(requestContext);\n            if (clientInfo) {\n              // While there is a clientAddress protobuf field, the backend\n              // doesn't pay attention to it yet, so we'll ignore it for now.\n              const {\n                clientName,\n                clientVersion,\n                clientReferenceId,\n              } = clientInfo;\n              // the backend makes the choice of mapping clientName => clientReferenceId if\n              // no custom reference id is provided\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientReferenceId = clientReferenceId || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          validationDidStart() {\n            return (validationErrors?: ReadonlyArray<Error>) => {\n              graphqlValidationFailure = validationErrors\n                ? validationErrors.length !== 0\n                : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            // If operation is undefined then `getOperationAST` returned null\n            // and an unknown operation was specified.\n            graphqlUnknownOperationName =\n              requestContext.operation === undefined;\n            await shouldIncludeRequest(requestContext);\n\n            if (metrics.captureTraces === false) {\n              // End early if we aren't going to send the trace so we continue to\n              // run the tree builder.\n              didEnd(requestContext);\n            }\n          },\n          executionDidStart() {\n            // If we stopped tracing early, return undefined so we don't trace\n            // an object\n            if (endDone) return;\n\n            return {\n              willResolveField({ info }) {\n                return treeBuilder.willResolveField(info);\n                // We could save the error into the trace during the end handler, but\n                // it won't have all the information that graphql-js adds to it later,\n                // like 'locations'.\n              },\n            };\n          },\n          willSendResponse(requestContext) {\n            // shouldTraceOperation will be called before this in `didResolveOperation`\n            // so we don't need to call it again here.\n\n            // See comment above for why `didEnd` must be called in two hooks.\n            didEnd(requestContext);\n          },\n          async didEncounterErrors(requestContext) {\n            // Search above for a comment about \"didResolveSource\" to see which\n            // of the pre-source-resolution errors we are intentionally avoiding.\n            if (!didResolveSource || endDone) return;\n            treeBuilder.didEncounterErrors(requestContext.errors);\n\n            // This will exit early if we have already set metrics.captureTraces\n            await shouldIncludeRequest(requestContext);\n\n            // See comment above for why `didEnd` must be called in two hooks.\n            // The type assertion is valid becaus we check didResolveSource above.\n            didEnd(\n              requestContext as GraphQLRequestContextDidEncounterErrors<\n                TContext\n              > &\n                GraphQLRequestContextDidResolveSource<TContext>,\n            );\n          },\n        };\n      };\n\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        },\n      };\n    },\n  };\n}\n\nexport function makeHTTPRequestHeaders(\n  http: Trace.IHTTP,\n  headers: Headers,\n  sendHeaders?: SendValuesBaseOptions,\n): void {\n  if (\n    !sendHeaders ||\n    ('none' in sendHeaders && sendHeaders.none) ||\n    ('all' in sendHeaders && !sendHeaders.all)\n  ) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    const lowerCaseKey = key.toLowerCase();\n    if (\n      ('exceptNames' in sendHeaders &&\n        // We assume that most users only have a few headers to hide, or will\n        // just set {none: true} ; we can change this linear-time\n        // operation if it causes real performance issues.\n        sendHeaders.exceptNames.some((exceptHeader) => {\n          // Headers are case-insensitive, and should be compared as such.\n          return exceptHeader.toLowerCase() === lowerCaseKey;\n        })) ||\n      ('onlyNames' in sendHeaders &&\n        !sendHeaders.onlyNames.some((header) => {\n          return header.toLowerCase() === lowerCaseKey;\n        }))\n    ) {\n      continue;\n    }\n\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http!.requestHeaders![key] = new Trace.HTTP.Values({\n          value: [value],\n        });\n    }\n  }\n}\n\nfunction defaultGenerateClientInfo({ request }: GraphQLRequestContext) {\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientReferenceIdHeaderKey = 'apollographql-client-reference-id';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n\n  // Default to using the `apollo-client-x` header fields if present.\n  // If none are present, fallback on the `clientInfo` query extension\n  // for backwards compatibility.\n  // The default value if neither header values nor query extension is\n  // set is the empty String for all fields (as per protobuf defaults)\n  if (\n    request.http?.headers?.get(clientNameHeaderKey) ||\n    request.http?.headers?.get(clientVersionHeaderKey) ||\n    request.http?.headers?.get(clientReferenceIdHeaderKey)\n  ) {\n    return {\n      clientName: request.http?.headers?.get(clientNameHeaderKey),\n      clientVersion: request.http?.headers?.get(clientVersionHeaderKey),\n      clientReferenceId: request.http?.headers?.get(clientReferenceIdHeaderKey),\n    };\n  } else if (request.extensions?.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\n\n// This plugin does nothing, but it ensures that ApolloServer won't try\n// to add a default ApolloServerPluginUsageReporting.\nexport function ApolloServerPluginUsageReportingDisabled(): InternalApolloServerPlugin {\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}