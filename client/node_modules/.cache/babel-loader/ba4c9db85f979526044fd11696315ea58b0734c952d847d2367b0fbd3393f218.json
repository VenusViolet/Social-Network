{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dateToProtoTimestamp = exports.TraceTreeBuilder = void 0;\nconst graphql_1 = require(\"graphql\");\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nfunction internalError(message) {\n  return new Error(`[internal apollo-server error] ${message}`);\n}\nclass TraceTreeBuilder {\n  constructor(options) {\n    this.rootNode = new apollo_reporting_protobuf_1.Trace.Node();\n    this.logger = console;\n    this.trace = new apollo_reporting_protobuf_1.Trace({\n      root: this.rootNode\n    });\n    this.stopped = false;\n    this.nodes = new Map([[responsePathAsString(), this.rootNode]]);\n    this.rewriteError = options.rewriteError;\n    if (options.logger) this.logger = options.logger;\n  }\n  startTiming() {\n    if (this.startHrTime) {\n      throw internalError('startTiming called twice!');\n    }\n    if (this.stopped) {\n      throw internalError('startTiming called after stopTiming!');\n    }\n    this.trace.startTime = dateToProtoTimestamp(new Date());\n    this.startHrTime = process.hrtime();\n  }\n  stopTiming() {\n    if (!this.startHrTime) {\n      throw internalError('stopTiming called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('stopTiming called twice!');\n    }\n    this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    this.trace.endTime = dateToProtoTimestamp(new Date());\n    this.stopped = true;\n  }\n  willResolveField(info) {\n    if (!this.startHrTime) {\n      throw internalError('willResolveField called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('willResolveField called after stopTiming!');\n    }\n    const path = info.path;\n    const node = this.newNode(path);\n    node.type = info.returnType.toString();\n    node.parentType = info.parentType.toString();\n    node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    if (typeof path.key === 'string' && path.key !== info.fieldName) {\n      node.originalFieldName = info.fieldName;\n    }\n    return () => {\n      node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    };\n  }\n  didEncounterErrors(errors) {\n    errors.forEach(err => {\n      if (err.extensions && err.extensions.serviceName) {\n        return;\n      }\n      const errorForReporting = this.rewriteAndNormalizeError(err);\n      if (errorForReporting === null) {\n        return;\n      }\n      this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));\n    });\n  }\n  addProtobufError(path, error) {\n    if (!this.startHrTime) {\n      throw internalError('addProtobufError called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('addProtobufError called after stopTiming!');\n    }\n    let node = this.rootNode;\n    if (Array.isArray(path)) {\n      const specificNode = this.nodes.get(path.join('.'));\n      if (specificNode) {\n        node = specificNode;\n      } else {\n        this.logger.warn(`Could not find node with path ${path.join('.')}; defaulting to put errors on root node.`);\n      }\n    }\n    node.error.push(error);\n  }\n  newNode(path) {\n    const node = new apollo_reporting_protobuf_1.Trace.Node();\n    const id = path.key;\n    if (typeof id === 'number') {\n      node.index = id;\n    } else {\n      node.responseName = id;\n    }\n    this.nodes.set(responsePathAsString(path), node);\n    const parentNode = this.ensureParentNode(path);\n    parentNode.child.push(node);\n    return node;\n  }\n  ensureParentNode(path) {\n    const parentPath = responsePathAsString(path.prev);\n    const parentNode = this.nodes.get(parentPath);\n    if (parentNode) {\n      return parentNode;\n    }\n    return this.newNode(path.prev);\n  }\n  rewriteAndNormalizeError(err) {\n    if (this.rewriteError) {\n      const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);\n      const rewrittenError = this.rewriteError(clonedError);\n      if (rewrittenError === null) {\n        return null;\n      }\n      if (!(rewrittenError instanceof graphql_1.GraphQLError)) {\n        return err;\n      }\n      return new graphql_1.GraphQLError(rewrittenError.message, err.nodes, err.source, err.positions, err.path, err.originalError, rewrittenError.extensions || err.extensions);\n    }\n    return err;\n  }\n}\nexports.TraceTreeBuilder = TraceTreeBuilder;\nfunction durationHrTimeToNanos(hrtime) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}\nfunction responsePathAsString(p) {\n  if (p === undefined) {\n    return '';\n  }\n  let res = String(p.key);\n  while ((p = p.prev) !== undefined) {\n    res = `${p.key}.${res}`;\n  }\n  return res;\n}\nfunction errorToProtobufError(error) {\n  return new apollo_reporting_protobuf_1.Trace.Error({\n    message: error.message,\n    location: (error.locations || []).map(_ref => {\n      let {\n        line,\n        column\n      } = _ref;\n      return new apollo_reporting_protobuf_1.Trace.Location({\n        line,\n        column\n      });\n    }),\n    json: JSON.stringify(error)\n  });\n}\nfunction dateToProtoTimestamp(date) {\n  const totalMillis = +date;\n  const millis = totalMillis % 1000;\n  return new apollo_reporting_protobuf_1.google.protobuf.Timestamp({\n    seconds: (totalMillis - millis) / 1000,\n    nanos: millis * 1e6\n  });\n}\nexports.dateToProtoTimestamp = dateToProtoTimestamp;","map":{"version":3,"names":["graphql_1","require","apollo_reporting_protobuf_1","internalError","message","Error","TraceTreeBuilder","constructor","options","rootNode","Trace","Node","logger","console","trace","root","stopped","nodes","Map","responsePathAsString","rewriteError","startTiming","startHrTime","startTime","dateToProtoTimestamp","Date","process","hrtime","stopTiming","durationNs","durationHrTimeToNanos","endTime","willResolveField","info","path","node","newNode","type","returnType","toString","parentType","key","fieldName","originalFieldName","didEncounterErrors","errors","forEach","err","extensions","serviceName","errorForReporting","rewriteAndNormalizeError","addProtobufError","errorToProtobufError","error","Array","isArray","specificNode","get","join","warn","push","id","index","responseName","set","parentNode","ensureParentNode","child","parentPath","prev","clonedError","Object","assign","create","getPrototypeOf","rewrittenError","GraphQLError","source","positions","originalError","exports","p","undefined","res","String","location","locations","map","_ref","line","column","Location","json","JSON","stringify","date","totalMillis","millis","google","protobuf","Timestamp","seconds","nanos"],"sources":["/Users/venusrodin/node_modules/apollo-server-core/src/plugin/traceTreeBuilder.ts"],"sourcesContent":["// This class is a helper for ApolloServerPluginUsageReporting and\n// ApolloServerPluginInlineTrace.\nimport { GraphQLError, GraphQLResolveInfo, ResponsePath } from 'graphql';\nimport { Trace, google } from 'apollo-reporting-protobuf';\nimport { Logger } from 'apollo-server-types';\n\nfunction internalError(message: string) {\n  return new Error(`[internal apollo-server error] ${message}`);\n}\n\nexport class TraceTreeBuilder {\n  private rootNode = new Trace.Node();\n  private logger: Logger = console;\n  public trace = new Trace({ root: this.rootNode });\n  public startHrTime?: [number, number];\n  private stopped = false;\n  private nodes = new Map<string, Trace.Node>([\n    [responsePathAsString(), this.rootNode],\n  ]);\n  private readonly rewriteError?: (err: GraphQLError) => GraphQLError | null;\n\n  public constructor(options: {\n    logger?: Logger;\n    rewriteError?: (err: GraphQLError) => GraphQLError | null;\n  }) {\n    this.rewriteError = options.rewriteError;\n    if (options.logger) this.logger = options.logger;\n  }\n\n  public startTiming() {\n    if (this.startHrTime) {\n      throw internalError('startTiming called twice!');\n    }\n    if (this.stopped) {\n      throw internalError('startTiming called after stopTiming!');\n    }\n    this.trace.startTime = dateToProtoTimestamp(new Date());\n    this.startHrTime = process.hrtime();\n  }\n\n  public stopTiming() {\n    if (!this.startHrTime) {\n      throw internalError('stopTiming called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('stopTiming called twice!');\n    }\n\n    this.trace.durationNs = durationHrTimeToNanos(\n      process.hrtime(this.startHrTime),\n    );\n    this.trace.endTime = dateToProtoTimestamp(new Date());\n    this.stopped = true;\n  }\n\n  public willResolveField(info: GraphQLResolveInfo): () => void {\n    if (!this.startHrTime) {\n      throw internalError('willResolveField called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('willResolveField called after stopTiming!');\n    }\n\n    const path = info.path;\n    const node = this.newNode(path);\n    node.type = info.returnType.toString();\n    node.parentType = info.parentType.toString();\n    node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    if (typeof path.key === 'string' && path.key !== info.fieldName) {\n      // This field was aliased; send the original field name too (for FieldStats).\n      node.originalFieldName = info.fieldName;\n    }\n\n    return () => {\n      node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    };\n  }\n\n  public didEncounterErrors(errors: readonly GraphQLError[]) {\n    errors.forEach((err) => {\n      // This is an error from a federated service. We will already be reporting\n      // it in the nested Trace in the query plan.\n      //\n      // XXX This probably shouldn't skip query or validation errors, which are\n      //      not in nested Traces because format() isn't called in this case! Or\n      //      maybe format() should be called in that case?\n      if (err.extensions && err.extensions.serviceName) {\n        return;\n      }\n\n      // In terms of reporting, errors can be re-written by the user by\n      // utilizing the `rewriteError` parameter.  This allows changing\n      // the message or stack to remove potentially sensitive information.\n      // Returning `null` will result in the error not being reported at all.\n      const errorForReporting = this.rewriteAndNormalizeError(err);\n\n      if (errorForReporting === null) {\n        return;\n      }\n\n      this.addProtobufError(\n        errorForReporting.path,\n        errorToProtobufError(errorForReporting),\n      );\n    });\n  }\n\n  private addProtobufError(\n    path: ReadonlyArray<string | number> | undefined,\n    error: Trace.Error,\n  ) {\n    if (!this.startHrTime) {\n      throw internalError('addProtobufError called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('addProtobufError called after stopTiming!');\n    }\n\n    // By default, put errors on the root node.\n    let node = this.rootNode;\n    // If a non-GraphQLError Error sneaks in here somehow with a non-array\n    // path, don't crash.\n    if (Array.isArray(path)) {\n      const specificNode = this.nodes.get(path.join('.'));\n      if (specificNode) {\n        node = specificNode;\n      } else {\n        this.logger.warn(\n          `Could not find node with path ${path.join(\n            '.',\n          )}; defaulting to put errors on root node.`,\n        );\n      }\n    }\n\n    node.error.push(error);\n  }\n\n  private newNode(path: ResponsePath): Trace.Node {\n    const node = new Trace.Node();\n    const id = path.key;\n    if (typeof id === 'number') {\n      node.index = id;\n    } else {\n      node.responseName = id;\n    }\n    this.nodes.set(responsePathAsString(path), node);\n    const parentNode = this.ensureParentNode(path);\n    parentNode.child.push(node);\n    return node;\n  }\n\n  private ensureParentNode(path: ResponsePath): Trace.Node {\n    const parentPath = responsePathAsString(path.prev);\n    const parentNode = this.nodes.get(parentPath);\n    if (parentNode) {\n      return parentNode;\n    }\n    // Because we set up the root path when creating this.nodes, we now know\n    // that path.prev isn't undefined.\n    return this.newNode(path.prev!);\n  }\n\n  private rewriteAndNormalizeError(err: GraphQLError): GraphQLError | null {\n    if (this.rewriteError) {\n      // Before passing the error to the user-provided `rewriteError` function,\n      // we'll make a shadow copy of the error so the user is free to change\n      // the object as they see fit.\n\n      // At this stage, this error is only for the purposes of reporting, but\n      // this is even more important since this is still a reference to the\n      // original error object and changing it would also change the error which\n      // is returned in the response to the client.\n\n      // For the clone, we'll create a new object which utilizes the exact same\n      // prototype of the error being reported.\n      const clonedError = Object.assign(\n        Object.create(Object.getPrototypeOf(err)),\n        err,\n      );\n\n      const rewrittenError = this.rewriteError(clonedError);\n\n      // Returning an explicit `null` means the user is requesting that the error\n      // not be reported to Apollo.\n      if (rewrittenError === null) {\n        return null;\n      }\n\n      // We don't want users to be inadvertently not reporting errors, so if\n      // they haven't returned an explicit `GraphQLError` (or `null`, handled\n      // above), then we'll report the error as usual.\n      if (!(rewrittenError instanceof GraphQLError)) {\n        return err;\n      }\n\n      // We only allow rewriteError to change the message and extensions of the\n      // error; we keep everything else the same. That way people don't have to\n      // do extra work to keep the error on the same trace node. We also keep\n      // extensions the same if it isn't explicitly changed (to, eg, {}). (Note\n      // that many of the fields of GraphQLError are not enumerable and won't\n      // show up in the trace (even in the json field) anyway.)\n      return new GraphQLError(\n        rewrittenError.message,\n        err.nodes,\n        err.source,\n        err.positions,\n        err.path,\n        err.originalError,\n        rewrittenError.extensions || err.extensions,\n      );\n    }\n    return err;\n  }\n}\n\n// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.\n//\n// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE\n// FROM process.hrtime() WITH NO ARGUMENTS.\n//\n// The entire point of the hrtime data structure is that the JavaScript Number\n// type can't represent all int64 values without loss of precision:\n// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function\n// on a duration that represents a value less than 104 days is fine. Calling\n// this function on an absolute time (which is generally roughly time since\n// system boot) is not a good idea.\n//\n// XXX We should probably use google.protobuf.Duration on the wire instead of\n// ever trying to store durations in a single number.\nfunction durationHrTimeToNanos(hrtime: [number, number]) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}\n\n// Convert from the linked-list ResponsePath format to a dot-joined\n// string. Includes the full path (field names and array indices).\nfunction responsePathAsString(p?: ResponsePath): string {\n  if (p === undefined) {\n    return '';\n  }\n\n  // A previous implementation used `responsePathAsArray` from `graphql-js/execution`,\n  // however, that employed an approach that created new arrays unnecessarily.\n  let res = String(p.key);\n\n  while ((p = p.prev) !== undefined) {\n    res = `${p.key}.${res}`;\n  }\n\n  return res;\n}\n\nfunction errorToProtobufError(error: GraphQLError): Trace.Error {\n  return new Trace.Error({\n    message: error.message,\n    location: (error.locations || []).map(\n      ({ line, column }) => new Trace.Location({ line, column }),\n    ),\n    json: JSON.stringify(error),\n  });\n}\n\n// Converts a JS Date into a Timestamp.\nexport function dateToProtoTimestamp(date: Date): google.protobuf.Timestamp {\n  const totalMillis = +date;\n  const millis = totalMillis % 1000;\n  return new google.protobuf.Timestamp({\n    seconds: (totalMillis - millis) / 1000,\n    nanos: millis * 1e6,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}